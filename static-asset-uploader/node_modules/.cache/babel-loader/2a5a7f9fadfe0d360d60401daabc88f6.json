{"ast":null,"code":"import _slicedToArray from \"@babel/runtime-corejs3/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime-corejs3/helpers/toConsumableArray\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";\nimport traverse from 'traverse';\nimport URL from 'url'; // This will match if the direct parent's key exactly matches an item.\n\nvar freelyNamedKeyParents = ['properties']; // This will match if the grandparent's key exactly matches an item.\n// NOTE that this is for finding non-free paths!\n\nvar nonFreelyNamedKeyGrandparents = ['properties']; // This will match if the joined parent path exactly matches an item.\n//\n// This is mostly useful for filtering out root-level reusable item names,\n// for example `[\"definitions\", \"$ref\"]`\n\nvar freelyNamedPaths = [// Swagger 2.0\n'definitions', 'parameters', 'responses', 'securityDefinitions', // OpenAPI 3.0\n'components/schemas', 'components/responses', 'components/parameters', 'components/securitySchemes']; // This will match if any of these items are substrings of the joined\n// parent path.\n//\n// Warning! These are powerful. Beware of edge cases.\n\nvar freelyNamedAncestors = ['schema/example', 'items/example'];\nexport function isFreelyNamed(parentPath) {\n  var parentKey = parentPath[parentPath.length - 1];\n  var grandparentKey = parentPath[parentPath.length - 2];\n  var parentStr = parentPath.join('/');\n  return (// eslint-disable-next-line max-len\n    freelyNamedKeyParents.indexOf(parentKey) > -1 && nonFreelyNamedKeyGrandparents.indexOf(grandparentKey) === -1 || freelyNamedPaths.indexOf(parentStr) > -1 || freelyNamedAncestors.some(function (el) {\n      return parentStr.indexOf(el) > -1;\n    })\n  );\n}\nexport function generateAbsoluteRefPatches(obj, basePath) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      specmap = _ref.specmap,\n      _ref$getBaseUrlForNod = _ref.getBaseUrlForNodePath,\n      getBaseUrlForNodePath = _ref$getBaseUrlForNod === void 0 ? function (path) {\n    var _context;\n\n    return specmap.getContext(_concatInstanceProperty(_context = []).call(_context, _toConsumableArray(basePath), _toConsumableArray(path))).baseDoc;\n  } : _ref$getBaseUrlForNod,\n      _ref$targetKeys = _ref.targetKeys,\n      targetKeys = _ref$targetKeys === void 0 ? ['$ref', '$$ref'] : _ref$targetKeys;\n\n  var patches = [];\n  traverse(obj).forEach(function callback() {\n    if (_includesInstanceProperty(targetKeys).call(targetKeys, this.key) && typeof this.node === 'string') {\n      var nodePath = this.path; // this node's path, relative to `obj`\n\n      var fullPath = _concatInstanceProperty(basePath).call(basePath, this.path);\n\n      var absolutifiedRefValue = absolutifyPointer(this.node, getBaseUrlForNodePath(nodePath));\n      patches.push(specmap.replace(fullPath, absolutifiedRefValue));\n    }\n  });\n  return patches;\n}\nexport function absolutifyPointer(pointer, baseUrl) {\n  var _context2;\n\n  var _pointer$split = pointer.split('#'),\n      _pointer$split2 = _slicedToArray(_pointer$split, 2),\n      urlPart = _pointer$split2[0],\n      fragmentPart = _pointer$split2[1];\n\n  var newRefUrlPart = URL.resolve(urlPart || '', baseUrl || '');\n  return fragmentPart ? _concatInstanceProperty(_context2 = \"\".concat(newRefUrlPart, \"#\")).call(_context2, fragmentPart) : newRefUrlPart;\n}","map":{"version":3,"sources":["/home/daniyal/Downloads/vap-webapp (1)/vap-webapp/web-content/static-asset-uploader/node_modules/swagger-client/es/specmap/helpers.js"],"names":["_slicedToArray","_toConsumableArray","_concatInstanceProperty","_includesInstanceProperty","traverse","URL","freelyNamedKeyParents","nonFreelyNamedKeyGrandparents","freelyNamedPaths","freelyNamedAncestors","isFreelyNamed","parentPath","parentKey","length","grandparentKey","parentStr","join","indexOf","some","el","generateAbsoluteRefPatches","obj","basePath","_ref","arguments","undefined","specmap","_ref$getBaseUrlForNod","getBaseUrlForNodePath","path","_context","getContext","call","baseDoc","_ref$targetKeys","targetKeys","patches","forEach","callback","key","node","nodePath","fullPath","absolutifiedRefValue","absolutifyPointer","push","replace","pointer","baseUrl","_context2","_pointer$split","split","_pointer$split2","urlPart","fragmentPart","newRefUrlPart","resolve","concat"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,8CAA3B;AACA,OAAOC,kBAAP,MAA+B,kDAA/B;AACA,OAAOC,uBAAP,MAAoC,uDAApC;AACA,OAAOC,yBAAP,MAAsC,yDAAtC;AACA,OAAOC,QAAP,MAAqB,UAArB;AACA,OAAOC,GAAP,MAAgB,KAAhB,C,CAAuB;;AAEvB,IAAIC,qBAAqB,GAAG,CAAC,YAAD,CAA5B,C,CAA4C;AAC5C;;AAEA,IAAIC,6BAA6B,GAAG,CAAC,YAAD,CAApC,C,CAAoD;AACpD;AACA;AACA;;AAEA,IAAIC,gBAAgB,GAAG,CAAC;AACxB,aADuB,EACR,YADQ,EACM,WADN,EACmB,qBADnB,EAC0C;AACjE,oBAFuB,EAED,sBAFC,EAEuB,uBAFvB,EAEgD,4BAFhD,CAAvB,C,CAEsG;AACtG;AACA;AACA;;AAEA,IAAIC,oBAAoB,GAAG,CAAC,gBAAD,EAAmB,eAAnB,CAA3B;AACA,OAAO,SAASC,aAAT,CAAuBC,UAAvB,EAAmC;AACxC,MAAIC,SAAS,GAAGD,UAAU,CAACA,UAAU,CAACE,MAAX,GAAoB,CAArB,CAA1B;AACA,MAAIC,cAAc,GAAGH,UAAU,CAACA,UAAU,CAACE,MAAX,GAAoB,CAArB,CAA/B;AACA,MAAIE,SAAS,GAAGJ,UAAU,CAACK,IAAX,CAAgB,GAAhB,CAAhB;AACA,SAAQ;AACNV,IAAAA,qBAAqB,CAACW,OAAtB,CAA8BL,SAA9B,IAA2C,CAAC,CAA5C,IAAiDL,6BAA6B,CAACU,OAA9B,CAAsCH,cAAtC,MAA0D,CAAC,CAA5G,IAAiHN,gBAAgB,CAACS,OAAjB,CAAyBF,SAAzB,IAAsC,CAAC,CAAxJ,IAA6JN,oBAAoB,CAACS,IAArB,CAA0B,UAAUC,EAAV,EAAc;AACnM,aAAOJ,SAAS,CAACE,OAAV,CAAkBE,EAAlB,IAAwB,CAAC,CAAhC;AACD,KAF4J;AAD/J;AAKD;AACD,OAAO,SAASC,0BAAT,CAAoCC,GAApC,EAAyCC,QAAzC,EAAmD;AACxD,MAAIC,IAAI,GAAGC,SAAS,CAACX,MAAV,GAAmB,CAAnB,IAAwBW,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA/E;AAAA,MACIE,OAAO,GAAGH,IAAI,CAACG,OADnB;AAAA,MAEIC,qBAAqB,GAAGJ,IAAI,CAACK,qBAFjC;AAAA,MAGIA,qBAAqB,GAAGD,qBAAqB,KAAK,KAAK,CAA/B,GAAmC,UAAUE,IAAV,EAAgB;AAC7E,QAAIC,QAAJ;;AAEA,WAAOJ,OAAO,CAACK,UAAR,CAAmB7B,uBAAuB,CAAC4B,QAAQ,GAAG,EAAZ,CAAvB,CAAuCE,IAAvC,CAA4CF,QAA5C,EAAsD7B,kBAAkB,CAACqB,QAAD,CAAxE,EAAoFrB,kBAAkB,CAAC4B,IAAD,CAAtG,CAAnB,EAAkII,OAAzI;AACD,GAJ2B,GAIxBN,qBAPJ;AAAA,MAQIO,eAAe,GAAGX,IAAI,CAACY,UAR3B;AAAA,MASIA,UAAU,GAAGD,eAAe,KAAK,KAAK,CAAzB,GAA6B,CAAC,MAAD,EAAS,OAAT,CAA7B,GAAiDA,eATlE;;AAWA,MAAIE,OAAO,GAAG,EAAd;AACAhC,EAAAA,QAAQ,CAACiB,GAAD,CAAR,CAAcgB,OAAd,CAAsB,SAASC,QAAT,GAAoB;AACxC,QAAInC,yBAAyB,CAACgC,UAAD,CAAzB,CAAsCH,IAAtC,CAA2CG,UAA3C,EAAuD,KAAKI,GAA5D,KAAoE,OAAO,KAAKC,IAAZ,KAAqB,QAA7F,EAAuG;AACrG,UAAIC,QAAQ,GAAG,KAAKZ,IAApB,CADqG,CAC3E;;AAE1B,UAAIa,QAAQ,GAAGxC,uBAAuB,CAACoB,QAAD,CAAvB,CAAkCU,IAAlC,CAAuCV,QAAvC,EAAiD,KAAKO,IAAtD,CAAf;;AAEA,UAAIc,oBAAoB,GAAGC,iBAAiB,CAAC,KAAKJ,IAAN,EAAYZ,qBAAqB,CAACa,QAAD,CAAjC,CAA5C;AACAL,MAAAA,OAAO,CAACS,IAAR,CAAanB,OAAO,CAACoB,OAAR,CAAgBJ,QAAhB,EAA0BC,oBAA1B,CAAb;AACD;AACF,GATD;AAUA,SAAOP,OAAP;AACD;AACD,OAAO,SAASQ,iBAAT,CAA2BG,OAA3B,EAAoCC,OAApC,EAA6C;AAClD,MAAIC,SAAJ;;AAEA,MAAIC,cAAc,GAAGH,OAAO,CAACI,KAAR,CAAc,GAAd,CAArB;AAAA,MACIC,eAAe,GAAGpD,cAAc,CAACkD,cAAD,EAAiB,CAAjB,CADpC;AAAA,MAEIG,OAAO,GAAGD,eAAe,CAAC,CAAD,CAF7B;AAAA,MAGIE,YAAY,GAAGF,eAAe,CAAC,CAAD,CAHlC;;AAKA,MAAIG,aAAa,GAAGlD,GAAG,CAACmD,OAAJ,CAAYH,OAAO,IAAI,EAAvB,EAA2BL,OAAO,IAAI,EAAtC,CAApB;AACA,SAAOM,YAAY,GAAGpD,uBAAuB,CAAC+C,SAAS,GAAG,GAAGQ,MAAH,CAAUF,aAAV,EAAyB,GAAzB,CAAb,CAAvB,CAAmEvB,IAAnE,CAAwEiB,SAAxE,EAAmFK,YAAnF,CAAH,GAAsGC,aAAzH;AACD","sourcesContent":["import _slicedToArray from \"@babel/runtime-corejs3/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime-corejs3/helpers/toConsumableArray\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";\nimport traverse from 'traverse';\nimport URL from 'url'; // This will match if the direct parent's key exactly matches an item.\n\nvar freelyNamedKeyParents = ['properties']; // This will match if the grandparent's key exactly matches an item.\n// NOTE that this is for finding non-free paths!\n\nvar nonFreelyNamedKeyGrandparents = ['properties']; // This will match if the joined parent path exactly matches an item.\n//\n// This is mostly useful for filtering out root-level reusable item names,\n// for example `[\"definitions\", \"$ref\"]`\n\nvar freelyNamedPaths = [// Swagger 2.0\n'definitions', 'parameters', 'responses', 'securityDefinitions', // OpenAPI 3.0\n'components/schemas', 'components/responses', 'components/parameters', 'components/securitySchemes']; // This will match if any of these items are substrings of the joined\n// parent path.\n//\n// Warning! These are powerful. Beware of edge cases.\n\nvar freelyNamedAncestors = ['schema/example', 'items/example'];\nexport function isFreelyNamed(parentPath) {\n  var parentKey = parentPath[parentPath.length - 1];\n  var grandparentKey = parentPath[parentPath.length - 2];\n  var parentStr = parentPath.join('/');\n  return (// eslint-disable-next-line max-len\n    freelyNamedKeyParents.indexOf(parentKey) > -1 && nonFreelyNamedKeyGrandparents.indexOf(grandparentKey) === -1 || freelyNamedPaths.indexOf(parentStr) > -1 || freelyNamedAncestors.some(function (el) {\n      return parentStr.indexOf(el) > -1;\n    })\n  );\n}\nexport function generateAbsoluteRefPatches(obj, basePath) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      specmap = _ref.specmap,\n      _ref$getBaseUrlForNod = _ref.getBaseUrlForNodePath,\n      getBaseUrlForNodePath = _ref$getBaseUrlForNod === void 0 ? function (path) {\n    var _context;\n\n    return specmap.getContext(_concatInstanceProperty(_context = []).call(_context, _toConsumableArray(basePath), _toConsumableArray(path))).baseDoc;\n  } : _ref$getBaseUrlForNod,\n      _ref$targetKeys = _ref.targetKeys,\n      targetKeys = _ref$targetKeys === void 0 ? ['$ref', '$$ref'] : _ref$targetKeys;\n\n  var patches = [];\n  traverse(obj).forEach(function callback() {\n    if (_includesInstanceProperty(targetKeys).call(targetKeys, this.key) && typeof this.node === 'string') {\n      var nodePath = this.path; // this node's path, relative to `obj`\n\n      var fullPath = _concatInstanceProperty(basePath).call(basePath, this.path);\n\n      var absolutifiedRefValue = absolutifyPointer(this.node, getBaseUrlForNodePath(nodePath));\n      patches.push(specmap.replace(fullPath, absolutifiedRefValue));\n    }\n  });\n  return patches;\n}\nexport function absolutifyPointer(pointer, baseUrl) {\n  var _context2;\n\n  var _pointer$split = pointer.split('#'),\n      _pointer$split2 = _slicedToArray(_pointer$split, 2),\n      urlPart = _pointer$split2[0],\n      fragmentPart = _pointer$split2[1];\n\n  var newRefUrlPart = URL.resolve(urlPart || '', baseUrl || '');\n  return fragmentPart ? _concatInstanceProperty(_context2 = \"\".concat(newRefUrlPart, \"#\")).call(_context2, fragmentPart) : newRefUrlPart;\n}"]},"metadata":{},"sourceType":"module"}