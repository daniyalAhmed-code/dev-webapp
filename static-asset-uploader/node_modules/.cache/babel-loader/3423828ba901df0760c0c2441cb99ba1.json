{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime-corejs3/helpers/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs3/regenerator\";\nimport Http from './http';\nimport mapSpec, { plugins } from './specmap';\nimport { normalizeSwagger } from './helpers';\nimport { ACCEPT_HEADER_VALUE_FOR_DOCUMENTS } from './constants';\nexport function makeFetchJSON(http) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var requestInterceptor = opts.requestInterceptor,\n      responseInterceptor = opts.responseInterceptor; // Set credentials with 'http.withCredentials' value\n\n  var credentials = http.withCredentials ? 'include' : 'same-origin';\n  return function (docPath) {\n    return http({\n      url: docPath,\n      loadSpec: true,\n      requestInterceptor: requestInterceptor,\n      responseInterceptor: responseInterceptor,\n      headers: {\n        Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS\n      },\n      credentials: credentials\n    }).then(function (res) {\n      return res.body;\n    });\n  };\n} // Wipe out the http cache\n\nexport function clearCache() {\n  plugins.refs.clearCache();\n}\nexport default function resolve(obj) {\n  var fetch = obj.fetch,\n      spec = obj.spec,\n      url = obj.url,\n      mode = obj.mode,\n      _obj$allowMetaPatches = obj.allowMetaPatches,\n      allowMetaPatches = _obj$allowMetaPatches === void 0 ? true : _obj$allowMetaPatches,\n      pathDiscriminator = obj.pathDiscriminator,\n      modelPropertyMacro = obj.modelPropertyMacro,\n      parameterMacro = obj.parameterMacro,\n      requestInterceptor = obj.requestInterceptor,\n      responseInterceptor = obj.responseInterceptor,\n      skipNormalization = obj.skipNormalization,\n      useCircularStructures = obj.useCircularStructures;\n  var http = obj.http,\n      baseDoc = obj.baseDoc; // @TODO Swagger-UI uses baseDoc instead of url, this is to allow both\n  // need to fix and pick one.\n\n  baseDoc = baseDoc || url; // Provide a default fetch implementation\n  // TODO fetch should be removed, and http used instead\n\n  http = fetch || http || Http;\n\n  if (!spec) {\n    return makeFetchJSON(http, {\n      requestInterceptor: requestInterceptor,\n      responseInterceptor: responseInterceptor\n    })(baseDoc).then(doResolve);\n  }\n\n  return doResolve(spec);\n\n  function doResolve(_spec) {\n    if (baseDoc) {\n      plugins.refs.docCache[baseDoc] = _spec;\n    } // Build a json-fetcher ( ie: give it a URL and get json out )\n\n\n    plugins.refs.fetchJSON = makeFetchJSON(http, {\n      requestInterceptor: requestInterceptor,\n      responseInterceptor: responseInterceptor\n    });\n    var plugs = [plugins.refs];\n\n    if (typeof parameterMacro === 'function') {\n      plugs.push(plugins.parameters);\n    }\n\n    if (typeof modelPropertyMacro === 'function') {\n      plugs.push(plugins.properties);\n    }\n\n    if (mode !== 'strict') {\n      plugs.push(plugins.allOf);\n    } // mapSpec is where the hard work happens\n\n\n    return mapSpec({\n      spec: _spec,\n      context: {\n        baseDoc: baseDoc\n      },\n      plugins: plugs,\n      allowMetaPatches: allowMetaPatches,\n      // allows adding .meta patches, which include adding `$$ref`s to the spec\n      pathDiscriminator: pathDiscriminator,\n      // for lazy resolution\n      parameterMacro: parameterMacro,\n      modelPropertyMacro: modelPropertyMacro,\n      useCircularStructures: useCircularStructures\n    }).then(skipNormalization ? /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(a) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", a);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }() : normalizeSwagger);\n  }\n}","map":{"version":3,"sources":["/home/daniyal/Downloads/vap-webapp (1)/vap-webapp/web-content/static-asset-uploader/node_modules/swagger-client/es/resolver.js"],"names":["_asyncToGenerator","_regeneratorRuntime","Http","mapSpec","plugins","normalizeSwagger","ACCEPT_HEADER_VALUE_FOR_DOCUMENTS","makeFetchJSON","http","opts","arguments","length","undefined","requestInterceptor","responseInterceptor","credentials","withCredentials","docPath","url","loadSpec","headers","Accept","then","res","body","clearCache","refs","resolve","obj","fetch","spec","mode","_obj$allowMetaPatches","allowMetaPatches","pathDiscriminator","modelPropertyMacro","parameterMacro","skipNormalization","useCircularStructures","baseDoc","doResolve","_spec","docCache","fetchJSON","plugs","push","parameters","properties","allOf","context","_ref","mark","_callee","a","wrap","_callee$","_context","prev","next","abrupt","stop","_x","apply"],"mappings":"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","sourcesContent":["import _asyncToGenerator from \"@babel/runtime-corejs3/helpers/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs3/regenerator\";\nimport Http from './http';\nimport mapSpec, { plugins } from './specmap';\nimport { normalizeSwagger } from './helpers';\nimport { ACCEPT_HEADER_VALUE_FOR_DOCUMENTS } from './constants';\nexport function makeFetchJSON(http) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var requestInterceptor = opts.requestInterceptor,\n      responseInterceptor = opts.responseInterceptor; // Set credentials with 'http.withCredentials' value\n\n  var credentials = http.withCredentials ? 'include' : 'same-origin';\n  return function (docPath) {\n    return http({\n      url: docPath,\n      loadSpec: true,\n      requestInterceptor: requestInterceptor,\n      responseInterceptor: responseInterceptor,\n      headers: {\n        Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS\n      },\n      credentials: credentials\n    }).then(function (res) {\n      return res.body;\n    });\n  };\n} // Wipe out the http cache\n\nexport function clearCache() {\n  plugins.refs.clearCache();\n}\nexport default function resolve(obj) {\n  var fetch = obj.fetch,\n      spec = obj.spec,\n      url = obj.url,\n      mode = obj.mode,\n      _obj$allowMetaPatches = obj.allowMetaPatches,\n      allowMetaPatches = _obj$allowMetaPatches === void 0 ? true : _obj$allowMetaPatches,\n      pathDiscriminator = obj.pathDiscriminator,\n      modelPropertyMacro = obj.modelPropertyMacro,\n      parameterMacro = obj.parameterMacro,\n      requestInterceptor = obj.requestInterceptor,\n      responseInterceptor = obj.responseInterceptor,\n      skipNormalization = obj.skipNormalization,\n      useCircularStructures = obj.useCircularStructures;\n  var http = obj.http,\n      baseDoc = obj.baseDoc; // @TODO Swagger-UI uses baseDoc instead of url, this is to allow both\n  // need to fix and pick one.\n\n  baseDoc = baseDoc || url; // Provide a default fetch implementation\n  // TODO fetch should be removed, and http used instead\n\n  http = fetch || http || Http;\n\n  if (!spec) {\n    return makeFetchJSON(http, {\n      requestInterceptor: requestInterceptor,\n      responseInterceptor: responseInterceptor\n    })(baseDoc).then(doResolve);\n  }\n\n  return doResolve(spec);\n\n  function doResolve(_spec) {\n    if (baseDoc) {\n      plugins.refs.docCache[baseDoc] = _spec;\n    } // Build a json-fetcher ( ie: give it a URL and get json out )\n\n\n    plugins.refs.fetchJSON = makeFetchJSON(http, {\n      requestInterceptor: requestInterceptor,\n      responseInterceptor: responseInterceptor\n    });\n    var plugs = [plugins.refs];\n\n    if (typeof parameterMacro === 'function') {\n      plugs.push(plugins.parameters);\n    }\n\n    if (typeof modelPropertyMacro === 'function') {\n      plugs.push(plugins.properties);\n    }\n\n    if (mode !== 'strict') {\n      plugs.push(plugins.allOf);\n    } // mapSpec is where the hard work happens\n\n\n    return mapSpec({\n      spec: _spec,\n      context: {\n        baseDoc: baseDoc\n      },\n      plugins: plugs,\n      allowMetaPatches: allowMetaPatches,\n      // allows adding .meta patches, which include adding `$$ref`s to the spec\n      pathDiscriminator: pathDiscriminator,\n      // for lazy resolution\n      parameterMacro: parameterMacro,\n      modelPropertyMacro: modelPropertyMacro,\n      useCircularStructures: useCircularStructures\n    }).then(skipNormalization ? /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(a) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", a);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }() : normalizeSwagger);\n  }\n}"]},"metadata":{},"sourceType":"module"}