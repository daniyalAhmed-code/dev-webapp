{"ast":null,"code":"import _typeof from \"@babel/runtime-corejs3/helpers/typeof\";\nimport _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";\nimport _WeakMap from \"@babel/runtime-corejs3/core-js-stable/weak-map\";\nimport _sliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/slice\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";\nimport _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";\nimport _URLSearchParams from \"@babel/runtime-corejs3/core-js-stable/url-search-params\";\nimport 'cross-fetch/polyfill';\n/* global fetch */\n\nimport jsYaml from 'js-yaml';\nimport url from 'url';\nimport lib from '.';\nimport createError from './create-error';\nimport { isFreelyNamed, absolutifyPointer } from '../helpers';\nimport { ACCEPT_HEADER_VALUE_FOR_DOCUMENTS } from '../../constants';\nvar ABSOLUTE_URL_REGEXP = new RegExp('^([a-z]+://|//)', 'i');\nvar JSONRefError = createError('JSONRefError', function cb(message, extra, oriError) {\n  this.originalError = oriError;\n\n  _Object$assign(this, extra || {});\n});\nvar docCache = {};\nvar specmapRefs = new _WeakMap();\nvar skipResolutionTestFns = [// OpenAPI 2.0 response examples\nfunction (path) {\n  return (// [\"paths\", *, *, \"responses\", *, \"examples\"]\n    path[0] === 'paths' && path[3] === 'responses' && path[5] === 'examples'\n  );\n}, // OpenAPI 3.0 Response Media Type Examples\nfunction (path) {\n  return (// [\"paths\", *, *, \"responses\", *, \"content\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"responses\", *, \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value'\n  );\n}, // OpenAPI 3.0 Request Body Media Type Examples\nfunction (path) {\n  return (// [\"paths\", *, *, \"requestBody\", \"content\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"requestBody\", \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value'\n  );\n}, // OAS 3.0 Parameter Examples\nfunction (path) {\n  return (// [\"paths\", *, \"parameters\", *, \"example\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"parameters\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[5] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, \"parameters\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'examples' && path[6] === 'value'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"parameters\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[5] === 'examples' && path[7] === 'value'\n  );\n}, function (path) {\n  return (// [\"paths\", *, \"parameters\", *, \"content\", *, \"example\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[4] === 'content' && path[7] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value'\n  );\n}];\n\nvar shouldSkipResolution = function shouldSkipResolution(path) {\n  return skipResolutionTestFns.some(function (fn) {\n    return fn(path);\n  });\n}; // =========================\n// Core\n// =========================\n\n/**\n * This plugin resolves the JSON pointers.\n * A major part of this plugin deals with cyclic references via 2 mechanisms.\n * 1. If a pointer was already resolved before in this path, halt.\n * 2. If the patch value points to one of the ancestors in this path, halt.\n *\n * Note that either one of these mechanism is sufficient, both must be in place.\n * For examples:\n *\n * Given the following spec, #1 alone is insufficient because after the 2nd\n * application, there will be a cyclic object reference.\n *   a.b.c: $ref-d\n *   d.e.f: $ref-a (per #1, safe to return patch as no immediate cycle)\n *\n * Given the following spec, #2 alone is insufficient because although there will\n * never be any cyclic object reference, the plugin will keep producing patches.\n *   a: $ref-b\n *   b: $ref-a\n */\n\n\nvar plugin = {\n  key: '$ref',\n  plugin: function plugin(ref, key, fullPath, specmap) {\n    var specmapInstance = specmap.getInstance();\n\n    var parent = _sliceInstanceProperty(fullPath).call(fullPath, 0, -1);\n\n    if (isFreelyNamed(parent) || shouldSkipResolution(parent)) {\n      return undefined;\n    }\n\n    var _specmap$getContext = specmap.getContext(fullPath),\n        baseDoc = _specmap$getContext.baseDoc;\n\n    if (typeof ref !== 'string') {\n      return new JSONRefError('$ref: must be a string (JSON-Ref)', {\n        $ref: ref,\n        baseDoc: baseDoc,\n        fullPath: fullPath\n      });\n    }\n\n    var splitString = split(ref);\n    var refPath = splitString[0];\n    var pointer = splitString[1] || '';\n    var basePath;\n\n    try {\n      basePath = baseDoc || refPath ? absoluteify(refPath, baseDoc) : null;\n    } catch (e) {\n      return wrapError(e, {\n        pointer: pointer,\n        $ref: ref,\n        basePath: basePath,\n        fullPath: fullPath\n      });\n    }\n\n    var promOrVal;\n    var tokens;\n\n    if (pointerAlreadyInPath(pointer, basePath, parent, specmap)) {\n      // Cyclic reference!\n      // if `useCircularStructures` is not set, just leave the reference\n      // unresolved, but absolutify it so that we don't leave an invalid $ref\n      // path in the content\n      if (!specmapInstance.useCircularStructures) {\n        var _absolutifiedRef = absolutifyPointer(ref, basePath);\n\n        if (ref === _absolutifiedRef) {\n          // avoids endless looping\n          // without this, the ref plugin never stops seeing this $ref\n          return null;\n        }\n\n        return lib.replace(fullPath, _absolutifiedRef);\n      }\n    }\n\n    if (basePath == null) {\n      tokens = jsonPointerToArray(pointer);\n      promOrVal = specmap.get(tokens);\n\n      if (typeof promOrVal === 'undefined') {\n        promOrVal = new JSONRefError(\"Could not resolve reference: \".concat(ref), {\n          pointer: pointer,\n          $ref: ref,\n          baseDoc: baseDoc,\n          fullPath: fullPath\n        });\n      }\n    } else {\n      promOrVal = extractFromDoc(basePath, pointer); // eslint-disable-next-line no-underscore-dangle\n\n      if (promOrVal.__value != null) {\n        promOrVal = promOrVal.__value; // eslint-disable-line no-underscore-dangle\n      } else {\n        promOrVal = promOrVal.catch(function (e) {\n          throw wrapError(e, {\n            pointer: pointer,\n            $ref: ref,\n            baseDoc: baseDoc,\n            fullPath: fullPath\n          });\n        });\n      }\n    }\n\n    if (promOrVal instanceof Error) {\n      return [lib.remove(fullPath), promOrVal];\n    }\n\n    var absolutifiedRef = absolutifyPointer(ref, basePath);\n    var patch = lib.replace(parent, promOrVal, {\n      $$ref: absolutifiedRef\n    });\n\n    if (basePath && basePath !== baseDoc) {\n      return [patch, lib.context(parent, {\n        baseDoc: basePath\n      })];\n    }\n\n    try {\n      // prevents circular values from being constructed, unless we specifically\n      // want that to happen\n      if (!patchValueAlreadyInPath(specmap.state, patch) || specmapInstance.useCircularStructures) {\n        return patch;\n      }\n    } catch (e) {\n      // if we're catching here, path traversal failed, so we should\n      // ditch without sending any patches back up.\n      //\n      // this is a narrow fix for the larger problem of patches being queued\n      // and then having the state they were generated against be modified\n      // before they are applied.\n      //\n      // TODO: re-engineer specmap patch/state management to avoid this\n      return null;\n    }\n\n    return undefined;\n  }\n};\n\nvar mod = _Object$assign(plugin, {\n  docCache: docCache,\n  absoluteify: absoluteify,\n  clearCache: clearCache,\n  JSONRefError: JSONRefError,\n  wrapError: wrapError,\n  getDoc: getDoc,\n  split: split,\n  extractFromDoc: extractFromDoc,\n  fetchJSON: fetchJSON,\n  extract: extract,\n  jsonPointerToArray: jsonPointerToArray,\n  unescapeJsonPointerToken: unescapeJsonPointerToken\n});\n\nexport default mod; // =========================\n// Utilities\n// =========================\n\n/**\n * Resolves a path and its base to an abolute URL.\n * @api public\n */\n\nfunction absoluteify(path, basePath) {\n  if (!ABSOLUTE_URL_REGEXP.test(path)) {\n    if (!basePath) {\n      var _context;\n\n      throw new JSONRefError(_concatInstanceProperty(_context = \"Tried to resolve a relative URL, without having a basePath. path: '\".concat(path, \"' basePath: '\")).call(_context, basePath, \"'\"));\n    }\n\n    return url.resolve(basePath, path);\n  }\n\n  return path;\n}\n/**\n * Wraps an error as JSONRefError.\n * @param  {Error} e      the error.\n * @param  {Object} extra (optional) optional data.\n * @return {Error}        an instance of JSONRefError.\n * @api public\n */\n\n\nfunction wrapError(e, extra) {\n  var message;\n\n  if (e && e.response && e.response.body) {\n    var _context2;\n\n    message = _concatInstanceProperty(_context2 = \"\".concat(e.response.body.code, \" \")).call(_context2, e.response.body.message);\n  } else {\n    message = e.message;\n  }\n\n  return new JSONRefError(\"Could not resolve reference: \".concat(message), extra, e);\n}\n/**\n * Splits a pointer by the hash delimiter.\n * @api public\n */\n\n\nfunction split(ref) {\n  return (ref + '').split('#'); // eslint-disable-line prefer-template\n}\n/**\n * Extracts a pointer from its document.\n * @param  {String} docPath the absolute document URL.\n * @param  {String} pointer the pointer whose value is to be extracted.\n * @return {Promise}        a promise of the pointer value.\n * @api public\n */\n\n\nfunction extractFromDoc(docPath, pointer) {\n  var doc = docCache[docPath];\n\n  if (doc && !lib.isPromise(doc)) {\n    // If doc is already available, return __value together with the promise.\n    // __value is for special handling in cycle check:\n    // pointerAlreadyInPath() won't work if patch.value is a promise,\n    // thus when that promise is finally resolved, cycle might happen (because\n    // `spec` and `docCache[basePath]` refer to the exact same object).\n    // See test \"should resolve a cyclic spec when baseDoc is specified\".\n    try {\n      var v = extract(pointer, doc);\n      return _Object$assign(_Promise.resolve(v), {\n        __value: v\n      });\n    } catch (e) {\n      return _Promise.reject(e);\n    }\n  }\n\n  return getDoc(docPath).then(function (_doc) {\n    return extract(pointer, _doc);\n  });\n}\n/**\n * Clears all document caches.\n * @param  {String} item (optional) the name of the cache item to be cleared.\n * @api public\n */\n\n\nfunction clearCache(item) {\n  if (typeof item !== 'undefined') {\n    delete docCache[item];\n  } else {\n    _Object$keys(docCache).forEach(function (key) {\n      delete docCache[key];\n    });\n  }\n}\n/**\n * Fetches and caches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\n\n\nfunction getDoc(docPath) {\n  var val = docCache[docPath];\n\n  if (val) {\n    return lib.isPromise(val) ? val : _Promise.resolve(val);\n  } // NOTE: we need to use `mod.fetchJSON` in order to be able to overwrite it.\n  // Any tips on how to make this cleaner, please ping!\n\n\n  docCache[docPath] = mod.fetchJSON(docPath).then(function (doc) {\n    docCache[docPath] = doc;\n    return doc;\n  });\n  return docCache[docPath];\n}\n/**\n * Fetches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\n\n\nfunction fetchJSON(docPath) {\n  return fetch(docPath, {\n    headers: {\n      Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS\n    },\n    loadSpec: true\n  }).then(function (res) {\n    return res.text();\n  }).then(function (text) {\n    return jsYaml.load(text);\n  });\n}\n/**\n * Extracts a pointer from an object.\n * @param  {String[]} pointer the JSON pointer.\n * @param  {Object} obj       an object whose value is to be extracted.\n * @return {Object}           the value to be extracted.\n * @api public\n */\n\n\nfunction extract(pointer, obj) {\n  var tokens = jsonPointerToArray(pointer);\n\n  if (tokens.length < 1) {\n    return obj;\n  }\n\n  var val = lib.getIn(obj, tokens);\n\n  if (typeof val === 'undefined') {\n    throw new JSONRefError(\"Could not resolve pointer: \".concat(pointer, \" does not exist in document\"), {\n      pointer: pointer\n    });\n  }\n\n  return val;\n}\n/**\n * Converts a JSON pointer to array.\n * @api public\n */\n\n\nfunction jsonPointerToArray(pointer) {\n  var _context3;\n\n  if (typeof pointer !== 'string') {\n    throw new TypeError(\"Expected a string, got a \".concat(_typeof(pointer)));\n  }\n\n  if (pointer[0] === '/') {\n    pointer = pointer.substr(1);\n  }\n\n  if (pointer === '') {\n    return [];\n  }\n\n  return _mapInstanceProperty(_context3 = pointer.split('/')).call(_context3, unescapeJsonPointerToken);\n}\n/**\n * Unescapes a JSON pointer.\n * @api public\n */\n\n\nfunction unescapeJsonPointerToken(token) {\n  if (typeof token !== 'string') {\n    return token;\n  }\n\n  var params = new _URLSearchParams(\"=\".concat(token.replace(/~1/g, '/').replace(/~0/g, '~')));\n  return params.get('');\n}\n/**\n * Escapes a JSON pointer.\n * @api public\n */\n\n\nfunction escapeJsonPointerToken(token) {\n  var _context4;\n\n  var params = new _URLSearchParams([['', token.replace(/~/g, '~0').replace(/\\//g, '~1')]]);\n  return _sliceInstanceProperty(_context4 = params.toString()).call(_context4, 1);\n}\n\nfunction arrayToJsonPointer(arr) {\n  if (arr.length === 0) {\n    return '';\n  }\n\n  return \"/\".concat(_mapInstanceProperty(arr).call(arr, escapeJsonPointerToken).join('/'));\n}\n\nvar pointerBoundaryChar = function pointerBoundaryChar(c) {\n  return !c || c === '/' || c === '#';\n};\n\nfunction pointerIsAParent(pointer, parentPointer) {\n  if (pointerBoundaryChar(parentPointer)) {\n    // This is the root of the document, so its naturally a parent\n    return true;\n  }\n\n  var nextChar = pointer.charAt(parentPointer.length);\n\n  var lastParentChar = _sliceInstanceProperty(parentPointer).call(parentPointer, -1);\n\n  return pointer.indexOf(parentPointer) === 0 && (!nextChar || nextChar === '/' || nextChar === '#') && lastParentChar !== '#';\n} // =========================\n// Private\n// =========================\n\n/**\n * Checks if this pointer points back to one or more pointers along the path.\n */\n\n\nfunction pointerAlreadyInPath(pointer, basePath, parent, specmap) {\n  var _context5, _context7;\n\n  var refs = specmapRefs.get(specmap);\n\n  if (!refs) {\n    // Stores all resolved references of a specmap instance.\n    // Schema: path -> pointer (path's $ref value).\n    refs = {};\n    specmapRefs.set(specmap, refs);\n  }\n\n  var parentPointer = arrayToJsonPointer(parent);\n\n  var fullyQualifiedPointer = _concatInstanceProperty(_context5 = \"\".concat(basePath || '<specmap-base>', \"#\")).call(_context5, pointer); // dirty hack to strip `allof/[index]` from the path, in order to avoid cases\n  // where we get false negatives because:\n  // - we resolve a path, then\n  // - allOf plugin collapsed `allOf/[index]` out of the path, then\n  // - we try to work on a child $ref within that collapsed path.\n  //\n  // because of the path collapse, we lose track of it in our specmapRefs hash\n  // solution: always throw the allOf constructs out of paths we store\n  // TODO: solve this with a global register, or by writing more metadata in\n  // either allOf or refs plugin\n\n\n  var safeParentPointer = parentPointer.replace(/allOf\\/\\d+\\/?/g, ''); // Case 1: direct cycle, e.g. a.b.c.$ref: '/a.b'\n  // Detect by checking that the parent path doesn't start with pointer.\n  // This only applies if the pointer is internal, i.e. basePath === rootPath (could be null)\n\n  var rootDoc = specmap.contextTree.get([]).baseDoc;\n\n  if (basePath === rootDoc && pointerIsAParent(safeParentPointer, pointer)) {\n    // eslint-disable-line\n    return true;\n  } // Case 2: indirect cycle\n  //  ex1: a.$ref: '/b'  &  b.c.$ref: '/b/c'\n  //  ex2: a.$ref: '/b/c'  &  b.c.$ref: '/b'\n  // Detect by retrieving all the $refs along the path of parent\n  // and checking if any starts with pointer or vice versa.\n\n\n  var currPath = '';\n  var hasIndirectCycle = parent.some(function (token) {\n    var _context6;\n\n    currPath = _concatInstanceProperty(_context6 = \"\".concat(currPath, \"/\")).call(_context6, escapeJsonPointerToken(token));\n    return refs[currPath] && refs[currPath].some(function (ref) {\n      return pointerIsAParent(ref, fullyQualifiedPointer) || pointerIsAParent(fullyQualifiedPointer, ref);\n    });\n  });\n\n  if (hasIndirectCycle) {\n    return true;\n  } // No cycle, this ref will be resolved, so stores it now for future detection.\n  // No need to store if has cycle, as parent path is a dead-end and won't be checked again.\n\n\n  refs[safeParentPointer] = _concatInstanceProperty(_context7 = refs[safeParentPointer] || []).call(_context7, fullyQualifiedPointer);\n  return undefined;\n}\n/**\n * Checks if the value of this patch ends up pointing to an ancestor along the path.\n */\n\n\nfunction patchValueAlreadyInPath(root, patch) {\n  var ancestors = [root];\n  patch.path.reduce(function (parent, p) {\n    ancestors.push(parent[p]);\n    return parent[p];\n  }, root);\n  return pointToAncestor(patch.value);\n\n  function pointToAncestor(obj) {\n    return lib.isObject(obj) && (ancestors.indexOf(obj) >= 0 || _Object$keys(obj).some(function (k) {\n      return pointToAncestor(obj[k]);\n    }));\n  }\n}","map":{"version":3,"sources":["/home/daniyal/Downloads/vap-webapp (1)/vap-webapp/web-content/static-asset-uploader/node_modules/swagger-client/es/specmap/lib/refs.js"],"names":["_typeof","_Object$assign","_WeakMap","_sliceInstanceProperty","_concatInstanceProperty","_Promise","_Object$keys","_mapInstanceProperty","_URLSearchParams","jsYaml","url","lib","createError","isFreelyNamed","absolutifyPointer","ACCEPT_HEADER_VALUE_FOR_DOCUMENTS","ABSOLUTE_URL_REGEXP","RegExp","JSONRefError","cb","message","extra","oriError","originalError","docCache","specmapRefs","skipResolutionTestFns","path","shouldSkipResolution","some","fn","plugin","key","ref","fullPath","specmap","specmapInstance","getInstance","parent","call","undefined","_specmap$getContext","getContext","baseDoc","$ref","splitString","split","refPath","pointer","basePath","absoluteify","e","wrapError","promOrVal","tokens","pointerAlreadyInPath","useCircularStructures","_absolutifiedRef","replace","jsonPointerToArray","get","concat","extractFromDoc","__value","catch","Error","remove","absolutifiedRef","patch","$$ref","context","patchValueAlreadyInPath","state","mod","clearCache","getDoc","fetchJSON","extract","unescapeJsonPointerToken","test","_context","resolve","response","body","_context2","code","docPath","doc","isPromise","v","reject","then","_doc","item","forEach","val","fetch","headers","Accept","loadSpec","res","text","load","obj","length","getIn","_context3","TypeError","substr","token","params","escapeJsonPointerToken","_context4","toString","arrayToJsonPointer","arr","join","pointerBoundaryChar","c","pointerIsAParent","parentPointer","nextChar","charAt","lastParentChar","indexOf","_context5","_context7","refs","set","fullyQualifiedPointer","safeParentPointer","rootDoc","contextTree","currPath","hasIndirectCycle","_context6","root","ancestors","reduce","p","push","pointToAncestor","value","isObject","k"],"mappings":"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","sourcesContent":["import _typeof from \"@babel/runtime-corejs3/helpers/typeof\";\nimport _Object$assign from \"@babel/runtime-corejs3/core-js-stable/object/assign\";\nimport _WeakMap from \"@babel/runtime-corejs3/core-js-stable/weak-map\";\nimport _sliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/slice\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _Promise from \"@babel/runtime-corejs3/core-js-stable/promise\";\nimport _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";\nimport _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";\nimport _URLSearchParams from \"@babel/runtime-corejs3/core-js-stable/url-search-params\";\nimport 'cross-fetch/polyfill';\n/* global fetch */\n\nimport jsYaml from 'js-yaml';\nimport url from 'url';\nimport lib from '.';\nimport createError from './create-error';\nimport { isFreelyNamed, absolutifyPointer } from '../helpers';\nimport { ACCEPT_HEADER_VALUE_FOR_DOCUMENTS } from '../../constants';\nvar ABSOLUTE_URL_REGEXP = new RegExp('^([a-z]+://|//)', 'i');\nvar JSONRefError = createError('JSONRefError', function cb(message, extra, oriError) {\n  this.originalError = oriError;\n\n  _Object$assign(this, extra || {});\n});\nvar docCache = {};\nvar specmapRefs = new _WeakMap();\nvar skipResolutionTestFns = [// OpenAPI 2.0 response examples\nfunction (path) {\n  return (// [\"paths\", *, *, \"responses\", *, \"examples\"]\n    path[0] === 'paths' && path[3] === 'responses' && path[5] === 'examples'\n  );\n}, // OpenAPI 3.0 Response Media Type Examples\nfunction (path) {\n  return (// [\"paths\", *, *, \"responses\", *, \"content\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"responses\", *, \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value'\n  );\n}, // OpenAPI 3.0 Request Body Media Type Examples\nfunction (path) {\n  return (// [\"paths\", *, *, \"requestBody\", \"content\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"requestBody\", \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value'\n  );\n}, // OAS 3.0 Parameter Examples\nfunction (path) {\n  return (// [\"paths\", *, \"parameters\", *, \"example\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"parameters\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[5] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, \"parameters\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'examples' && path[6] === 'value'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"parameters\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[5] === 'examples' && path[7] === 'value'\n  );\n}, function (path) {\n  return (// [\"paths\", *, \"parameters\", *, \"content\", *, \"example\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[2] === 'parameters' && path[4] === 'content' && path[6] === 'examples' && path[8] === 'value'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"example\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[4] === 'content' && path[7] === 'example'\n  );\n}, function (path) {\n  return (// [\"paths\", *, *, \"parameters\", *, \"content\", *, \"examples\", *, \"value\"]\n    path[0] === 'paths' && path[3] === 'parameters' && path[5] === 'content' && path[7] === 'examples' && path[9] === 'value'\n  );\n}];\n\nvar shouldSkipResolution = function shouldSkipResolution(path) {\n  return skipResolutionTestFns.some(function (fn) {\n    return fn(path);\n  });\n}; // =========================\n// Core\n// =========================\n\n/**\n * This plugin resolves the JSON pointers.\n * A major part of this plugin deals with cyclic references via 2 mechanisms.\n * 1. If a pointer was already resolved before in this path, halt.\n * 2. If the patch value points to one of the ancestors in this path, halt.\n *\n * Note that either one of these mechanism is sufficient, both must be in place.\n * For examples:\n *\n * Given the following spec, #1 alone is insufficient because after the 2nd\n * application, there will be a cyclic object reference.\n *   a.b.c: $ref-d\n *   d.e.f: $ref-a (per #1, safe to return patch as no immediate cycle)\n *\n * Given the following spec, #2 alone is insufficient because although there will\n * never be any cyclic object reference, the plugin will keep producing patches.\n *   a: $ref-b\n *   b: $ref-a\n */\n\n\nvar plugin = {\n  key: '$ref',\n  plugin: function plugin(ref, key, fullPath, specmap) {\n    var specmapInstance = specmap.getInstance();\n\n    var parent = _sliceInstanceProperty(fullPath).call(fullPath, 0, -1);\n\n    if (isFreelyNamed(parent) || shouldSkipResolution(parent)) {\n      return undefined;\n    }\n\n    var _specmap$getContext = specmap.getContext(fullPath),\n        baseDoc = _specmap$getContext.baseDoc;\n\n    if (typeof ref !== 'string') {\n      return new JSONRefError('$ref: must be a string (JSON-Ref)', {\n        $ref: ref,\n        baseDoc: baseDoc,\n        fullPath: fullPath\n      });\n    }\n\n    var splitString = split(ref);\n    var refPath = splitString[0];\n    var pointer = splitString[1] || '';\n    var basePath;\n\n    try {\n      basePath = baseDoc || refPath ? absoluteify(refPath, baseDoc) : null;\n    } catch (e) {\n      return wrapError(e, {\n        pointer: pointer,\n        $ref: ref,\n        basePath: basePath,\n        fullPath: fullPath\n      });\n    }\n\n    var promOrVal;\n    var tokens;\n\n    if (pointerAlreadyInPath(pointer, basePath, parent, specmap)) {\n      // Cyclic reference!\n      // if `useCircularStructures` is not set, just leave the reference\n      // unresolved, but absolutify it so that we don't leave an invalid $ref\n      // path in the content\n      if (!specmapInstance.useCircularStructures) {\n        var _absolutifiedRef = absolutifyPointer(ref, basePath);\n\n        if (ref === _absolutifiedRef) {\n          // avoids endless looping\n          // without this, the ref plugin never stops seeing this $ref\n          return null;\n        }\n\n        return lib.replace(fullPath, _absolutifiedRef);\n      }\n    }\n\n    if (basePath == null) {\n      tokens = jsonPointerToArray(pointer);\n      promOrVal = specmap.get(tokens);\n\n      if (typeof promOrVal === 'undefined') {\n        promOrVal = new JSONRefError(\"Could not resolve reference: \".concat(ref), {\n          pointer: pointer,\n          $ref: ref,\n          baseDoc: baseDoc,\n          fullPath: fullPath\n        });\n      }\n    } else {\n      promOrVal = extractFromDoc(basePath, pointer); // eslint-disable-next-line no-underscore-dangle\n\n      if (promOrVal.__value != null) {\n        promOrVal = promOrVal.__value; // eslint-disable-line no-underscore-dangle\n      } else {\n        promOrVal = promOrVal.catch(function (e) {\n          throw wrapError(e, {\n            pointer: pointer,\n            $ref: ref,\n            baseDoc: baseDoc,\n            fullPath: fullPath\n          });\n        });\n      }\n    }\n\n    if (promOrVal instanceof Error) {\n      return [lib.remove(fullPath), promOrVal];\n    }\n\n    var absolutifiedRef = absolutifyPointer(ref, basePath);\n    var patch = lib.replace(parent, promOrVal, {\n      $$ref: absolutifiedRef\n    });\n\n    if (basePath && basePath !== baseDoc) {\n      return [patch, lib.context(parent, {\n        baseDoc: basePath\n      })];\n    }\n\n    try {\n      // prevents circular values from being constructed, unless we specifically\n      // want that to happen\n      if (!patchValueAlreadyInPath(specmap.state, patch) || specmapInstance.useCircularStructures) {\n        return patch;\n      }\n    } catch (e) {\n      // if we're catching here, path traversal failed, so we should\n      // ditch without sending any patches back up.\n      //\n      // this is a narrow fix for the larger problem of patches being queued\n      // and then having the state they were generated against be modified\n      // before they are applied.\n      //\n      // TODO: re-engineer specmap patch/state management to avoid this\n      return null;\n    }\n\n    return undefined;\n  }\n};\n\nvar mod = _Object$assign(plugin, {\n  docCache: docCache,\n  absoluteify: absoluteify,\n  clearCache: clearCache,\n  JSONRefError: JSONRefError,\n  wrapError: wrapError,\n  getDoc: getDoc,\n  split: split,\n  extractFromDoc: extractFromDoc,\n  fetchJSON: fetchJSON,\n  extract: extract,\n  jsonPointerToArray: jsonPointerToArray,\n  unescapeJsonPointerToken: unescapeJsonPointerToken\n});\n\nexport default mod; // =========================\n// Utilities\n// =========================\n\n/**\n * Resolves a path and its base to an abolute URL.\n * @api public\n */\n\nfunction absoluteify(path, basePath) {\n  if (!ABSOLUTE_URL_REGEXP.test(path)) {\n    if (!basePath) {\n      var _context;\n\n      throw new JSONRefError(_concatInstanceProperty(_context = \"Tried to resolve a relative URL, without having a basePath. path: '\".concat(path, \"' basePath: '\")).call(_context, basePath, \"'\"));\n    }\n\n    return url.resolve(basePath, path);\n  }\n\n  return path;\n}\n/**\n * Wraps an error as JSONRefError.\n * @param  {Error} e      the error.\n * @param  {Object} extra (optional) optional data.\n * @return {Error}        an instance of JSONRefError.\n * @api public\n */\n\n\nfunction wrapError(e, extra) {\n  var message;\n\n  if (e && e.response && e.response.body) {\n    var _context2;\n\n    message = _concatInstanceProperty(_context2 = \"\".concat(e.response.body.code, \" \")).call(_context2, e.response.body.message);\n  } else {\n    message = e.message;\n  }\n\n  return new JSONRefError(\"Could not resolve reference: \".concat(message), extra, e);\n}\n/**\n * Splits a pointer by the hash delimiter.\n * @api public\n */\n\n\nfunction split(ref) {\n  return (ref + '').split('#'); // eslint-disable-line prefer-template\n}\n/**\n * Extracts a pointer from its document.\n * @param  {String} docPath the absolute document URL.\n * @param  {String} pointer the pointer whose value is to be extracted.\n * @return {Promise}        a promise of the pointer value.\n * @api public\n */\n\n\nfunction extractFromDoc(docPath, pointer) {\n  var doc = docCache[docPath];\n\n  if (doc && !lib.isPromise(doc)) {\n    // If doc is already available, return __value together with the promise.\n    // __value is for special handling in cycle check:\n    // pointerAlreadyInPath() won't work if patch.value is a promise,\n    // thus when that promise is finally resolved, cycle might happen (because\n    // `spec` and `docCache[basePath]` refer to the exact same object).\n    // See test \"should resolve a cyclic spec when baseDoc is specified\".\n    try {\n      var v = extract(pointer, doc);\n      return _Object$assign(_Promise.resolve(v), {\n        __value: v\n      });\n    } catch (e) {\n      return _Promise.reject(e);\n    }\n  }\n\n  return getDoc(docPath).then(function (_doc) {\n    return extract(pointer, _doc);\n  });\n}\n/**\n * Clears all document caches.\n * @param  {String} item (optional) the name of the cache item to be cleared.\n * @api public\n */\n\n\nfunction clearCache(item) {\n  if (typeof item !== 'undefined') {\n    delete docCache[item];\n  } else {\n    _Object$keys(docCache).forEach(function (key) {\n      delete docCache[key];\n    });\n  }\n}\n/**\n * Fetches and caches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\n\n\nfunction getDoc(docPath) {\n  var val = docCache[docPath];\n\n  if (val) {\n    return lib.isPromise(val) ? val : _Promise.resolve(val);\n  } // NOTE: we need to use `mod.fetchJSON` in order to be able to overwrite it.\n  // Any tips on how to make this cleaner, please ping!\n\n\n  docCache[docPath] = mod.fetchJSON(docPath).then(function (doc) {\n    docCache[docPath] = doc;\n    return doc;\n  });\n  return docCache[docPath];\n}\n/**\n * Fetches a document.\n * @param  {String} docPath the absolute URL of the document.\n * @return {Promise}        a promise of the document content.\n * @api public\n */\n\n\nfunction fetchJSON(docPath) {\n  return fetch(docPath, {\n    headers: {\n      Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS\n    },\n    loadSpec: true\n  }).then(function (res) {\n    return res.text();\n  }).then(function (text) {\n    return jsYaml.load(text);\n  });\n}\n/**\n * Extracts a pointer from an object.\n * @param  {String[]} pointer the JSON pointer.\n * @param  {Object} obj       an object whose value is to be extracted.\n * @return {Object}           the value to be extracted.\n * @api public\n */\n\n\nfunction extract(pointer, obj) {\n  var tokens = jsonPointerToArray(pointer);\n\n  if (tokens.length < 1) {\n    return obj;\n  }\n\n  var val = lib.getIn(obj, tokens);\n\n  if (typeof val === 'undefined') {\n    throw new JSONRefError(\"Could not resolve pointer: \".concat(pointer, \" does not exist in document\"), {\n      pointer: pointer\n    });\n  }\n\n  return val;\n}\n/**\n * Converts a JSON pointer to array.\n * @api public\n */\n\n\nfunction jsonPointerToArray(pointer) {\n  var _context3;\n\n  if (typeof pointer !== 'string') {\n    throw new TypeError(\"Expected a string, got a \".concat(_typeof(pointer)));\n  }\n\n  if (pointer[0] === '/') {\n    pointer = pointer.substr(1);\n  }\n\n  if (pointer === '') {\n    return [];\n  }\n\n  return _mapInstanceProperty(_context3 = pointer.split('/')).call(_context3, unescapeJsonPointerToken);\n}\n/**\n * Unescapes a JSON pointer.\n * @api public\n */\n\n\nfunction unescapeJsonPointerToken(token) {\n  if (typeof token !== 'string') {\n    return token;\n  }\n\n  var params = new _URLSearchParams(\"=\".concat(token.replace(/~1/g, '/').replace(/~0/g, '~')));\n  return params.get('');\n}\n/**\n * Escapes a JSON pointer.\n * @api public\n */\n\n\nfunction escapeJsonPointerToken(token) {\n  var _context4;\n\n  var params = new _URLSearchParams([['', token.replace(/~/g, '~0').replace(/\\//g, '~1')]]);\n  return _sliceInstanceProperty(_context4 = params.toString()).call(_context4, 1);\n}\n\nfunction arrayToJsonPointer(arr) {\n  if (arr.length === 0) {\n    return '';\n  }\n\n  return \"/\".concat(_mapInstanceProperty(arr).call(arr, escapeJsonPointerToken).join('/'));\n}\n\nvar pointerBoundaryChar = function pointerBoundaryChar(c) {\n  return !c || c === '/' || c === '#';\n};\n\nfunction pointerIsAParent(pointer, parentPointer) {\n  if (pointerBoundaryChar(parentPointer)) {\n    // This is the root of the document, so its naturally a parent\n    return true;\n  }\n\n  var nextChar = pointer.charAt(parentPointer.length);\n\n  var lastParentChar = _sliceInstanceProperty(parentPointer).call(parentPointer, -1);\n\n  return pointer.indexOf(parentPointer) === 0 && (!nextChar || nextChar === '/' || nextChar === '#') && lastParentChar !== '#';\n} // =========================\n// Private\n// =========================\n\n/**\n * Checks if this pointer points back to one or more pointers along the path.\n */\n\n\nfunction pointerAlreadyInPath(pointer, basePath, parent, specmap) {\n  var _context5, _context7;\n\n  var refs = specmapRefs.get(specmap);\n\n  if (!refs) {\n    // Stores all resolved references of a specmap instance.\n    // Schema: path -> pointer (path's $ref value).\n    refs = {};\n    specmapRefs.set(specmap, refs);\n  }\n\n  var parentPointer = arrayToJsonPointer(parent);\n\n  var fullyQualifiedPointer = _concatInstanceProperty(_context5 = \"\".concat(basePath || '<specmap-base>', \"#\")).call(_context5, pointer); // dirty hack to strip `allof/[index]` from the path, in order to avoid cases\n  // where we get false negatives because:\n  // - we resolve a path, then\n  // - allOf plugin collapsed `allOf/[index]` out of the path, then\n  // - we try to work on a child $ref within that collapsed path.\n  //\n  // because of the path collapse, we lose track of it in our specmapRefs hash\n  // solution: always throw the allOf constructs out of paths we store\n  // TODO: solve this with a global register, or by writing more metadata in\n  // either allOf or refs plugin\n\n\n  var safeParentPointer = parentPointer.replace(/allOf\\/\\d+\\/?/g, ''); // Case 1: direct cycle, e.g. a.b.c.$ref: '/a.b'\n  // Detect by checking that the parent path doesn't start with pointer.\n  // This only applies if the pointer is internal, i.e. basePath === rootPath (could be null)\n\n  var rootDoc = specmap.contextTree.get([]).baseDoc;\n\n  if (basePath === rootDoc && pointerIsAParent(safeParentPointer, pointer)) {\n    // eslint-disable-line\n    return true;\n  } // Case 2: indirect cycle\n  //  ex1: a.$ref: '/b'  &  b.c.$ref: '/b/c'\n  //  ex2: a.$ref: '/b/c'  &  b.c.$ref: '/b'\n  // Detect by retrieving all the $refs along the path of parent\n  // and checking if any starts with pointer or vice versa.\n\n\n  var currPath = '';\n  var hasIndirectCycle = parent.some(function (token) {\n    var _context6;\n\n    currPath = _concatInstanceProperty(_context6 = \"\".concat(currPath, \"/\")).call(_context6, escapeJsonPointerToken(token));\n    return refs[currPath] && refs[currPath].some(function (ref) {\n      return pointerIsAParent(ref, fullyQualifiedPointer) || pointerIsAParent(fullyQualifiedPointer, ref);\n    });\n  });\n\n  if (hasIndirectCycle) {\n    return true;\n  } // No cycle, this ref will be resolved, so stores it now for future detection.\n  // No need to store if has cycle, as parent path is a dead-end and won't be checked again.\n\n\n  refs[safeParentPointer] = _concatInstanceProperty(_context7 = refs[safeParentPointer] || []).call(_context7, fullyQualifiedPointer);\n  return undefined;\n}\n/**\n * Checks if the value of this patch ends up pointing to an ancestor along the path.\n */\n\n\nfunction patchValueAlreadyInPath(root, patch) {\n  var ancestors = [root];\n  patch.path.reduce(function (parent, p) {\n    ancestors.push(parent[p]);\n    return parent[p];\n  }, root);\n  return pointToAncestor(patch.value);\n\n  function pointToAncestor(obj) {\n    return lib.isObject(obj) && (ancestors.indexOf(obj) >= 0 || _Object$keys(obj).some(function (k) {\n      return pointToAncestor(obj[k]);\n    }));\n  }\n}"]},"metadata":{},"sourceType":"module"}