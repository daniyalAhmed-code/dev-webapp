{"ast":null,"code":"// Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React,{useLayoutEffect,useRef}from'react';import ReactDOM from'react-dom';// react-router\nimport{Link}from'react-router-dom';// mobx\nimport{observable}from'mobx';// markdown parsing\nimport frontmatter from'front-matter';import marked from'marked';import{jsx as _jsx}from\"react/jsx-runtime\";export const fragments=observable({});export const loadFragments=()=>{loadHtml('/custom-content/content-fragments/GettingStarted.md','GettingStarted');loadHtml('/custom-content/content-fragments/Home.md','Home');loadHtml('/custom-content/content-fragments/APIs.md','APIs');};/**\n * Pre-load the custom-content markdown, parses its frontmatter, and renders it as JSX. This method\n * is asynchronous and doesn't actually return anything -- instead, it acts on a MobX Observable --\n * the fragment. The fragment is an object with a `jsx` property that maps to the rendered\n * component, and any number of other properties collected from the front-matter.\n *\n * @param {String} path   Path to the file to load in. Should be a markdown file.\n * @param {String} fragment   Name of the fragment. Determines where rendered data gets stored.\n *\n * @returns {Object}\n */function loadHtml(path,fragment){// if we want to display a loading indicator, this would be where\nfragments[fragment]={jsx:()=>null};window.fetch(path).then(response=>response.text().then(text=>{const parsedMarkdown=frontmatter(text);const html=marked(parsedMarkdown.body,{headerPrefix:'header-',silent:true});fragments[fragment]={jsx:()=>/*#__PURE__*/_jsx(ShowHTML,{html:html}),...parsedMarkdown.attributes};}));}function ShowHTML(_ref){let{html}=_ref;/** @type {import(\"react\").MutableRefObject<HTMLDivElement>} */const ref=useRef();// Easier to do it here than to use a separate `useMemo` hook.\nuseLayoutEffect(()=>{// Normal links will work, but the cause a full page reload. We don't want that, so we replace\n// them with react-router Links. However, replacing external links with react-router Links\n// causes them to not work at all. We don't want that either, so we attempt to determine if a\n// link is external or not, and replace them as appropriate.\nconst mountPoints=[];const links=ref.current.getElementsByTagName('a');for(let i=0;i<links.length;i++){const link=links[i];// if absolute url, use an `a` tag\n// https://stackoverflow.com/a/19709846/4060061\nif(/^(?:[a-z]+:)?\\/\\//i.test(link.href)){link.target='_blank';link.rel='noopener noreferrer';}else{// Replace links with react-router-dom tags so that they route correctly\nconst span=document.createElement('span');// If there's CSS, don't listen to it.\nspan.style.setProperty('display','inline','important');ReactDOM.render(/*#__PURE__*/_jsx(Link,{to:link.href,target:link.target,dangerouslySetInnerHTML:{__html:link.innerHTML}}),span);link.replaceWith(span);mountPoints.push(span);}}// Gracefully unmount any mount points that were added\nreturn()=>{mountPoints.forEach(elem=>{ReactDOM.render(null,elem);});};},[]);return/*#__PURE__*/_jsx(\"div\",{ref:ref,dangerouslySetInnerHTML:{__html:html}});}","map":{"version":3,"sources":["/home/daniyal/Downloads/vap-webapp (1)/vap-webapp/web-content/static-asset-uploader/src/services/get-fragments.jsx"],"names":["React","useLayoutEffect","useRef","ReactDOM","Link","observable","frontmatter","marked","fragments","loadFragments","loadHtml","path","fragment","jsx","window","fetch","then","response","text","parsedMarkdown","html","body","headerPrefix","silent","attributes","ShowHTML","ref","mountPoints","links","current","getElementsByTagName","i","length","link","test","href","target","rel","span","document","createElement","style","setProperty","render","__html","innerHTML","replaceWith","push","forEach","elem"],"mappings":"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","sourcesContent":["// Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useLayoutEffect, useRef } from 'react'\nimport ReactDOM from 'react-dom'\n\n// react-router\nimport { Link } from 'react-router-dom'\n\n// mobx\nimport { observable } from 'mobx'\n\n// markdown parsing\nimport frontmatter from 'front-matter'\nimport marked from 'marked'\n\nexport const fragments = observable({})\n\nexport const loadFragments = () => {\n  loadHtml('/custom-content/content-fragments/GettingStarted.md', 'GettingStarted')\n  loadHtml('/custom-content/content-fragments/Home.md', 'Home')\n  loadHtml('/custom-content/content-fragments/APIs.md', 'APIs')\n}\n\n/**\n * Pre-load the custom-content markdown, parses its frontmatter, and renders it as JSX. This method\n * is asynchronous and doesn't actually return anything -- instead, it acts on a MobX Observable --\n * the fragment. The fragment is an object with a `jsx` property that maps to the rendered\n * component, and any number of other properties collected from the front-matter.\n *\n * @param {String} path   Path to the file to load in. Should be a markdown file.\n * @param {String} fragment   Name of the fragment. Determines where rendered data gets stored.\n *\n * @returns {Object}\n */\nfunction loadHtml (path, fragment) {\n  // if we want to display a loading indicator, this would be where\n  fragments[fragment] = { jsx: () => null }\n\n  window.fetch(path).then(response => response.text().then(text => {\n    const parsedMarkdown = frontmatter(text)\n    const html = marked(parsedMarkdown.body, {\n      headerPrefix: 'header-',\n      silent: true\n    })\n\n    fragments[fragment] = {\n      jsx: () => <ShowHTML html={html} />,\n      ...parsedMarkdown.attributes\n    }\n  }))\n}\n\nfunction ShowHTML ({ html }) {\n  /** @type {import(\"react\").MutableRefObject<HTMLDivElement>} */\n  const ref = useRef()\n\n  // Easier to do it here than to use a separate `useMemo` hook.\n  useLayoutEffect(() => {\n    // Normal links will work, but the cause a full page reload. We don't want that, so we replace\n    // them with react-router Links. However, replacing external links with react-router Links\n    // causes them to not work at all. We don't want that either, so we attempt to determine if a\n    // link is external or not, and replace them as appropriate.\n\n    const mountPoints = []\n    const links = ref.current.getElementsByTagName('a')\n\n    for (let i = 0; i < links.length; i++) {\n      const link = links[i]\n      // if absolute url, use an `a` tag\n      // https://stackoverflow.com/a/19709846/4060061\n      if (/^(?:[a-z]+:)?\\/\\//i.test(link.href)) {\n        link.target = '_blank'\n        link.rel = 'noopener noreferrer'\n      } else {\n        // Replace links with react-router-dom tags so that they route correctly\n        const span = document.createElement('span')\n        // If there's CSS, don't listen to it.\n        span.style.setProperty('display', 'inline', 'important')\n        ReactDOM.render(<Link\n          to={link.href}\n          target={link.target}\n          dangerouslySetInnerHTML={{ __html: link.innerHTML }}\n        />, span)\n        link.replaceWith(span)\n        mountPoints.push(span)\n      }\n    }\n\n    // Gracefully unmount any mount points that were added\n    return () => {\n      mountPoints.forEach(elem => {\n        ReactDOM.render(null, elem)\n      })\n    }\n  }, [])\n\n  return <div ref={ref} dangerouslySetInnerHTML={{ __html: html }} />\n}\n"]},"metadata":{},"sourceType":"module"}