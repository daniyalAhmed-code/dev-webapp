{"ast":null,"code":"// Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport _ from'lodash';import{apiGatewayClientWithCredentials}from'./api';import{store}from'./state';import{isAdmin}from'./self';/* Catalog and API Utils */ /**\n *\n * Does all operations to get user data at once.\n *\n * @param {Boolean} bustCache=true   Ignore the cache and re-make the calls? Defaults to true.\n */export function updateAllUserData(){let bustCache=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;const promises=[updateUsagePlansAndApisList(bustCache),updateSubscriptions(bustCache),updateApiKey(bustCache)];if(isAdmin()){promises.push(updateVisibility(bustCache));}return Promise.all(promises);}/**\n *\n * Update the catalog for the current user. Both request and response are cached, so unless the cache is busted, this should only ever make one network call.\n *\n * @param {Boolean} [bustCache=false]   Ignore the cache and re-make the network call. Defaults to false.\n *\n */export function updateUsagePlansAndApisList(){let bustCache=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;// if we've already tried, just return that promise\nif(!bustCache&&catalogPromiseCache)return catalogPromiseCache;store.apiList.loaded=false;// eslint-disable-next-line no-return-assign\nreturn catalogPromiseCache=apiGatewayClientWithCredentials().then(apiGatewayClient=>apiGatewayClient.get('/catalog',{},{},{})).then(_ref=>{let{data={apiGateway:[],generic:[]}}=_ref;store.usagePlans=data.apiGateway;store.apiList={loaded:true,apiGateway:getApiGatewayApisFromUsagePlans(store.usagePlans),// MUST create\ngeneric:data.generic};}).catch(()=>{store.usagePlans=[];store.apiList={loaded:true,apiGateway:[],generic:[]};});}let catalogPromiseCache;// WARNING: Don't touch this. Should only be used by updateCatalogAndApisList.\n/**\n * A function that takes an input usage plans and creates an list of apis out of it.\n *\n * - Makes sure each api has a non-recursive 'usagePlan' object\n *\n * returns an array of apis\n */function getApiGatewayApisFromUsagePlans(usagePlans){return usagePlans.reduce((acc,usagePlan)=>{usagePlan.apis.forEach(api=>{api.usagePlan=_.cloneDeep(usagePlan);// remove the apis from the cloned usagePlan so we don't go circular\ndelete api.usagePlan.apis;});return acc.concat(usagePlan.apis);},[]);}/**\n * Return the API with the provided apiId. Can also provide the special strings \"FIRST\" or \"ANY\" to get the first API returned. Can select the api returned as a side-effect.\n *\n * @param {String} apiId   An apiId or the special strings 'FIRST' or 'ANY'. 'FIRST' and 'ANY' both return the first api encountered.\n * @param {Boolean} [selectIt=false]   If true, sets the found API as the current 'selected' API.\n */export function getApi(apiId){let selectIt=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let stage=arguments.length>2?arguments[2]:undefined;let cacheBust=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;return updateUsagePlansAndApisList(cacheBust).then(()=>{let thisApi;const allApis=[].concat(store.apiList.apiGateway,store.apiList.generic);if(allApis.length){if(apiId==='ANY'||apiId==='FIRST'){thisApi=allApis[0];}else{thisApi=allApis.find(api=>api.apiId===apiId&&api.apiStage===stage);if(!thisApi){thisApi=allApis.find(api=>api.id.toString()===apiId);}}}if(selectIt)store.api=thisApi;return thisApi;});}export function updateVisibility(){let cacheBust=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;return apiGatewayClientWithCredentials().then(app=>app.get('/admin/catalog/visibility',{},{},{})).then(_ref2=>{let{data}=_ref2;return store.visibility=data;});}/* Subscription Utils */ /**\n * Fetch and update subscriptions store. Uses caching to determine if it should actually fetch or return the stored result.\n *\n * @param {Boolean} [bustCache=false]   Ignore the cache and re-make the network call. Defaults to false.\n */export function updateSubscriptions(){let bustCache=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;const subscriptionsOrPromise=store.subscriptions.length?store.subscriptions:subscriptionsPromiseCache;if(!bustCache&&subscriptionsOrPromise)return Promise.resolve(subscriptionsOrPromise);// eslint-disable-next-line no-return-assign\nreturn subscriptionsPromiseCache=apiGatewayClientWithCredentials().then(apiGatewayClient=>apiGatewayClient.get('/subscriptions',{},{},{})).then(_ref3=>{let{data}=_ref3;return store.subscriptions=data;});}let subscriptionsPromiseCache;// WARNING: Don't touch this. Should only be used by updateCatalogAndApisList.\nexport function getSubscribedUsagePlan(usagePlanId){return store.subscriptions.find(sub=>sub.id===usagePlanId);}export function subscribe(usagePlanId){return apiGatewayClientWithCredentials().then(apiGatewayClient=>apiGatewayClient.put('/subscriptions/'+usagePlanId,{},{})).then(()=>updateSubscriptions(true));}export function unsubscribe(usagePlanId){return apiGatewayClientWithCredentials().then(apiGatewayClient=>apiGatewayClient.delete(\"/subscriptions/\".concat(usagePlanId),{},{})).then(()=>updateSubscriptions(true));}/**\n *\n * Fetches and updates the apiKey in the store. Both request and response are cached, so unless the cache is busted, this should only ever make one network call.\n *\n */export function updateApiKey(bustCache){const apiKeyOrPromise=store.apiKey?store.apiKey:apiKeyPromiseCache;if(!bustCache&&apiKeyOrPromise)return Promise.resolve(apiKeyOrPromise);store.apiKeyFetchFailed=false;const MAX_RETRIES=5;let remaining=MAX_RETRIES;const timeouts=[250,500,1000,2000];function loop(){remaining--;const promise=apiGatewayClientWithCredentials().then(apiGatewayClient=>apiGatewayClient.get('/apikey',{},{},{})).then(_ref4=>{let{data}=_ref4;return store.apiKey=data.value;});return remaining?promise.catch(()=>new Promise(resolve=>setTimeout(resolve,timeouts[remaining])).then(loop)):promise;}return(apiKeyPromiseCache=loop()).catch(()=>{store.apiKeyFetchFailed=true;});}let apiKeyPromiseCache;export function fetchUsage(usagePlanId){const date=new Date();const start=new Date(date.getFullYear(),date.getMonth(),1).toJSON().split('T')[0];const end=date.toJSON().split('T')[0];return apiGatewayClientWithCredentials().then(apiGatewayClient=>apiGatewayClient.get('/subscriptions/'+usagePlanId+'/usage',{start,end},{}));}export function mapUsageByDate(usage,usedOrRemaining){const dates={};Object.keys(usage.items).forEach(apiKeyId=>{const apiKeyUsage=mapApiKeyUsageByDate(usage.items[apiKeyId],usage.startDate,usedOrRemaining);// handles the bizarre case that the user has more than one api key\n// currently not possible (and my never be), so we probably don't need it\napiKeyUsage.forEach(dailyUsage=>{const date=dailyUsage[0];const used=dailyUsage[1];const remaining=dailyUsage[2];if(!dates[date]){dates[date]={used:0,remaining:0};}dates[date].used+=used;dates[date].remaining+=remaining;});});const usageByDate=Object.keys(dates).sort().map(date=>[parseInt(date,10),dates[date].used,dates[date].remaining]);return usageByDate;}function mapApiKeyUsageByDate(apiKeyUsage,startDate){const apiKeyDate=new Date(startDate);if(apiKeyUsage&&!Array.isArray(apiKeyUsage[0])){apiKeyUsage=[apiKeyUsage];}return apiKeyUsage.map(usage=>{const date=apiKeyDate.setDate(apiKeyDate.getDate());const item=[date,...usage];apiKeyDate.setDate(apiKeyDate.getDate()+1);return item;});}// Marketplace support is currently broken\n// /* Marketplace integration */\n//\n// export function confirmMarketplaceSubscription (usagePlanId, token) {\n//   if (!usagePlanId) {\n//     return\n//   }\n//\n//   return apiGatewayClientWithCredentials()\n//     .then(apiGatewayClient => apiGatewayClient.put('/marketplace-subscriptions/' + usagePlanId, {}, { token: token }))\n// }","map":{"version":3,"sources":["/home/daniyal/Downloads/vap-webapp (1)/vap-webapp/web-content/static-asset-uploader/src/services/api-catalog.js"],"names":["_","apiGatewayClientWithCredentials","store","isAdmin","updateAllUserData","bustCache","promises","updateUsagePlansAndApisList","updateSubscriptions","updateApiKey","push","updateVisibility","Promise","all","catalogPromiseCache","apiList","loaded","then","apiGatewayClient","get","data","apiGateway","generic","usagePlans","getApiGatewayApisFromUsagePlans","catch","reduce","acc","usagePlan","apis","forEach","api","cloneDeep","concat","getApi","apiId","selectIt","stage","cacheBust","thisApi","allApis","length","find","apiStage","id","toString","app","visibility","subscriptionsOrPromise","subscriptions","subscriptionsPromiseCache","resolve","getSubscribedUsagePlan","usagePlanId","sub","subscribe","put","unsubscribe","delete","apiKeyOrPromise","apiKey","apiKeyPromiseCache","apiKeyFetchFailed","MAX_RETRIES","remaining","timeouts","loop","promise","value","setTimeout","fetchUsage","date","Date","start","getFullYear","getMonth","toJSON","split","end","mapUsageByDate","usage","usedOrRemaining","dates","Object","keys","items","apiKeyId","apiKeyUsage","mapApiKeyUsageByDate","startDate","dailyUsage","used","usageByDate","sort","map","parseInt","apiKeyDate","Array","isArray","setDate","getDate","item"],"mappings":"AAAA;AACA;AAEA,MAAOA,CAAAA,CAAP,KAAc,QAAd,CAEA,OAASC,+BAAT,KAAgD,OAAhD,CACA,OAASC,KAAT,KAAsB,SAAtB,CACA,OAASC,OAAT,KAAwB,QAAxB,CAEA,2B,CAEA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASC,CAAAA,iBAAT,EAA8C,IAAlBC,CAAAA,SAAkB,2DAAN,IAAM,CACnD,KAAMC,CAAAA,QAAQ,CAAG,CACfC,2BAA2B,CAACF,SAAD,CADZ,CAEfG,mBAAmB,CAACH,SAAD,CAFJ,CAGfI,YAAY,CAACJ,SAAD,CAHG,CAAjB,CAMA,GAAIF,OAAO,EAAX,CAAe,CAAEG,QAAQ,CAACI,IAAT,CAAcC,gBAAgB,CAACN,SAAD,CAA9B,EAA4C,CAE7D,MAAOO,CAAAA,OAAO,CAACC,GAAR,CAAYP,QAAZ,CAAP,CACD,CAED;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASC,CAAAA,2BAAT,EAAyD,IAAnBF,CAAAA,SAAmB,2DAAP,KAAO,CAC9D;AACA,GAAI,CAACA,SAAD,EAAcS,mBAAlB,CAAuC,MAAOA,CAAAA,mBAAP,CAEvCZ,KAAK,CAACa,OAAN,CAAcC,MAAd,CAAuB,KAAvB,CAEA;AACA,MAAOF,CAAAA,mBAAmB,CAAGb,+BAA+B,GACzDgB,IAD0B,CACrBC,gBAAgB,EAAIA,gBAAgB,CAACC,GAAjB,CAAqB,UAArB,CAAiC,EAAjC,CAAqC,EAArC,CAAyC,EAAzC,CADC,EAE1BF,IAF0B,CAErB,MAAgD,IAA/C,CAAEG,IAAI,CAAG,CAAEC,UAAU,CAAE,EAAd,CAAkBC,OAAO,CAAE,EAA3B,CAAT,CAA+C,MACpDpB,KAAK,CAACqB,UAAN,CAAmBH,IAAI,CAACC,UAAxB,CACAnB,KAAK,CAACa,OAAN,CAAgB,CACdC,MAAM,CAAE,IADM,CAEdK,UAAU,CAAEG,+BAA+B,CAACtB,KAAK,CAACqB,UAAP,CAF7B,CAEiD;AAC/DD,OAAO,CAAEF,IAAI,CAACE,OAHA,CAAhB,CAKD,CAT0B,EAU1BG,KAV0B,CAUpB,IAAM,CACXvB,KAAK,CAACqB,UAAN,CAAmB,EAAnB,CACArB,KAAK,CAACa,OAAN,CAAgB,CACdC,MAAM,CAAE,IADM,CAEdK,UAAU,CAAE,EAFE,CAGdC,OAAO,CAAE,EAHK,CAAhB,CAKD,CAjB0B,CAA7B,CAkBD,CACD,GAAIR,CAAAA,mBAAJ,CAAwB;AAExB;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAASU,CAAAA,+BAAT,CAA0CD,UAA1C,CAAsD,CACpD,MAAOA,CAAAA,UAAU,CAACG,MAAX,CAAkB,CAACC,GAAD,CAAMC,SAAN,GAAoB,CAC3CA,SAAS,CAACC,IAAV,CAAeC,OAAf,CAAuBC,GAAG,EAAI,CAC5BA,GAAG,CAACH,SAAJ,CAAgB5B,CAAC,CAACgC,SAAF,CAAYJ,SAAZ,CAAhB,CACA;AACA,MAAOG,CAAAA,GAAG,CAACH,SAAJ,CAAcC,IAArB,CACD,CAJD,EAMA,MAAOF,CAAAA,GAAG,CAACM,MAAJ,CAAWL,SAAS,CAACC,IAArB,CAAP,CACD,CARM,CAQJ,EARI,CAAP,CASD,CAED;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASK,CAAAA,MAAT,CAAiBC,KAAjB,CAAoE,IAA5CC,CAAAA,QAA4C,2DAAjC,KAAiC,IAA1BC,CAAAA,KAA0B,8CAAnBC,CAAAA,SAAmB,2DAAP,KAAO,CACzE,MAAO/B,CAAAA,2BAA2B,CAAC+B,SAAD,CAA3B,CACJrB,IADI,CACC,IAAM,CACV,GAAIsB,CAAAA,OAAJ,CAEA,KAAMC,CAAAA,OAAO,CAAG,GAAGP,MAAH,CAAU/B,KAAK,CAACa,OAAN,CAAcM,UAAxB,CAAoCnB,KAAK,CAACa,OAAN,CAAcO,OAAlD,CAAhB,CAEA,GAAIkB,OAAO,CAACC,MAAZ,CAAoB,CAClB,GAAIN,KAAK,GAAK,KAAV,EAAmBA,KAAK,GAAK,OAAjC,CAA0C,CACxCI,OAAO,CAAGC,OAAO,CAAC,CAAD,CAAjB,CACD,CAFD,IAEO,CACLD,OAAO,CAAGC,OAAO,CAACE,IAAR,CAAaX,GAAG,EAAKA,GAAG,CAACI,KAAJ,GAAcA,KAAd,EAAuBJ,GAAG,CAACY,QAAJ,GAAiBN,KAA7D,CAAV,CAEA,GAAI,CAACE,OAAL,CAAc,CACZA,OAAO,CAAGC,OAAO,CAACE,IAAR,CAAaX,GAAG,EAAKA,GAAG,CAACa,EAAJ,CAAOC,QAAP,KAAsBV,KAA3C,CAAV,CACD,CACF,CACF,CAED,GAAIC,QAAJ,CAAclC,KAAK,CAAC6B,GAAN,CAAYQ,OAAZ,CAEd,MAAOA,CAAAA,OAAP,CACD,CArBI,CAAP,CAsBD,CAED,MAAO,SAAS5B,CAAAA,gBAAT,EAA8C,IAAnB2B,CAAAA,SAAmB,2DAAP,KAAO,CACnD,MAAOrC,CAAAA,+BAA+B,GACnCgB,IADI,CACC6B,GAAG,EAAIA,GAAG,CAAC3B,GAAJ,CAAQ,2BAAR,CAAqC,EAArC,CAAyC,EAAzC,CAA6C,EAA7C,CADR,EAEJF,IAFI,CAEC,WAAC,CAAEG,IAAF,CAAD,aAAelB,CAAAA,KAAK,CAAC6C,UAAN,CAAmB3B,IAAlC,EAFD,CAAP,CAGD,CAED,wB,CAEA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASZ,CAAAA,mBAAT,EAAiD,IAAnBH,CAAAA,SAAmB,2DAAP,KAAO,CACtD,KAAM2C,CAAAA,sBAAsB,CAAG9C,KAAK,CAAC+C,aAAN,CAAoBR,MAApB,CAA6BvC,KAAK,CAAC+C,aAAnC,CAAmDC,yBAAlF,CACA,GAAI,CAAC7C,SAAD,EAAc2C,sBAAlB,CAA0C,MAAOpC,CAAAA,OAAO,CAACuC,OAAR,CAAgBH,sBAAhB,CAAP,CAE1C;AACA,MAAOE,CAAAA,yBAAyB,CAAGjD,+BAA+B,GAC/DgB,IADgC,CAC3BC,gBAAgB,EAAIA,gBAAgB,CAACC,GAAjB,CAAqB,gBAArB,CAAuC,EAAvC,CAA2C,EAA3C,CAA+C,EAA/C,CADO,EAEhCF,IAFgC,CAE3B,WAAC,CAAEG,IAAF,CAAD,aAAelB,CAAAA,KAAK,CAAC+C,aAAN,CAAsB7B,IAArC,EAF2B,CAAnC,CAGD,CACD,GAAI8B,CAAAA,yBAAJ,CAA8B;AAE9B,MAAO,SAASE,CAAAA,sBAAT,CAAiCC,WAAjC,CAA8C,CACnD,MAAOnD,CAAAA,KAAK,CAAC+C,aAAN,CAAoBP,IAApB,CAAyBY,GAAG,EAAIA,GAAG,CAACV,EAAJ,GAAWS,WAA3C,CAAP,CACD,CAED,MAAO,SAASE,CAAAA,SAAT,CAAoBF,WAApB,CAAiC,CACtC,MAAOpD,CAAAA,+BAA+B,GACnCgB,IADI,CACCC,gBAAgB,EAAIA,gBAAgB,CAACsC,GAAjB,CAAqB,kBAAoBH,WAAzC,CAAsD,EAAtD,CAA0D,EAA1D,CADrB,EAEJpC,IAFI,CAEC,IAAMT,mBAAmB,CAAC,IAAD,CAF1B,CAAP,CAGD,CAED,MAAO,SAASiD,CAAAA,WAAT,CAAsBJ,WAAtB,CAAmC,CACxC,MAAOpD,CAAAA,+BAA+B,GACnCgB,IADI,CACCC,gBAAgB,EAAIA,gBAAgB,CAACwC,MAAjB,0BAA0CL,WAA1C,EAAyD,EAAzD,CAA6D,EAA7D,CADrB,EAEJpC,IAFI,CAEC,IAAMT,mBAAmB,CAAC,IAAD,CAF1B,CAAP,CAGD,CAED;AACA;AACA;AACA;AACA,GACA,MAAO,SAASC,CAAAA,YAAT,CAAuBJ,SAAvB,CAAkC,CACvC,KAAMsD,CAAAA,eAAe,CAAGzD,KAAK,CAAC0D,MAAN,CAAe1D,KAAK,CAAC0D,MAArB,CAA8BC,kBAAtD,CACA,GAAI,CAACxD,SAAD,EAAcsD,eAAlB,CAAmC,MAAO/C,CAAAA,OAAO,CAACuC,OAAR,CAAgBQ,eAAhB,CAAP,CACnCzD,KAAK,CAAC4D,iBAAN,CAA0B,KAA1B,CAEA,KAAMC,CAAAA,WAAW,CAAG,CAApB,CACA,GAAIC,CAAAA,SAAS,CAAGD,WAAhB,CAEA,KAAME,CAAAA,QAAQ,CAAG,CACf,GADe,CAEf,GAFe,CAGf,IAHe,CAIf,IAJe,CAAjB,CAOA,QAASC,CAAAA,IAAT,EAAiB,CACfF,SAAS,GACT,KAAMG,CAAAA,OAAO,CAAGlE,+BAA+B,GAC5CgB,IADa,CACRC,gBAAgB,EAAIA,gBAAgB,CAACC,GAAjB,CAAqB,SAArB,CAAgC,EAAhC,CAAoC,EAApC,CAAwC,EAAxC,CADZ,EAEbF,IAFa,CAER,WAAC,CAAEG,IAAF,CAAD,aAAelB,CAAAA,KAAK,CAAC0D,MAAN,CAAexC,IAAI,CAACgD,KAAnC,EAFQ,CAAhB,CAIA,MAAOJ,CAAAA,SAAS,CACZG,OAAO,CAAC1C,KAAR,CAAc,IACd,GAAIb,CAAAA,OAAJ,CAAYuC,OAAO,EAAIkB,UAAU,CAAClB,OAAD,CAAUc,QAAQ,CAACD,SAAD,CAAlB,CAAjC,EAAiE/C,IAAjE,CAAsEiD,IAAtE,CADA,CADY,CAIZC,OAJJ,CAKD,CAED,MAAO,CAACN,kBAAkB,CAAGK,IAAI,EAA1B,EAA8BzC,KAA9B,CAAoC,IAAM,CAC/CvB,KAAK,CAAC4D,iBAAN,CAA0B,IAA1B,CACD,CAFM,CAAP,CAGD,CACD,GAAID,CAAAA,kBAAJ,CAEA,MAAO,SAASS,CAAAA,UAAT,CAAqBjB,WAArB,CAAkC,CACvC,KAAMkB,CAAAA,IAAI,CAAG,GAAIC,CAAAA,IAAJ,EAAb,CACA,KAAMC,CAAAA,KAAK,CAAG,GAAID,CAAAA,IAAJ,CAASD,IAAI,CAACG,WAAL,EAAT,CAA6BH,IAAI,CAACI,QAAL,EAA7B,CAA8C,CAA9C,EAAiDC,MAAjD,GAA0DC,KAA1D,CAAgE,GAAhE,EAAqE,CAArE,CAAd,CACA,KAAMC,CAAAA,GAAG,CAAGP,IAAI,CAACK,MAAL,GAAcC,KAAd,CAAoB,GAApB,EAAyB,CAAzB,CAAZ,CACA,MAAO5E,CAAAA,+BAA+B,GACnCgB,IADI,CACCC,gBAAgB,EAAIA,gBAAgB,CAACC,GAAjB,CAAqB,kBAAoBkC,WAApB,CAAkC,QAAvD,CAAiE,CAAEoB,KAAF,CAASK,GAAT,CAAjE,CAAiF,EAAjF,CADrB,CAAP,CAED,CAED,MAAO,SAASC,CAAAA,cAAT,CAAyBC,KAAzB,CAAgCC,eAAhC,CAAiD,CACtD,KAAMC,CAAAA,KAAK,CAAG,EAAd,CACAC,MAAM,CAACC,IAAP,CAAYJ,KAAK,CAACK,KAAlB,EAAyBvD,OAAzB,CAAiCwD,QAAQ,EAAI,CAC3C,KAAMC,CAAAA,WAAW,CAAGC,oBAAoB,CAACR,KAAK,CAACK,KAAN,CAAYC,QAAZ,CAAD,CAAwBN,KAAK,CAACS,SAA9B,CAAyCR,eAAzC,CAAxC,CAEA;AACA;AACAM,WAAW,CAACzD,OAAZ,CAAoB4D,UAAU,EAAI,CAChC,KAAMnB,CAAAA,IAAI,CAAGmB,UAAU,CAAC,CAAD,CAAvB,CACA,KAAMC,CAAAA,IAAI,CAAGD,UAAU,CAAC,CAAD,CAAvB,CACA,KAAM1B,CAAAA,SAAS,CAAG0B,UAAU,CAAC,CAAD,CAA5B,CAEA,GAAI,CAACR,KAAK,CAACX,IAAD,CAAV,CAAkB,CAAEW,KAAK,CAACX,IAAD,CAAL,CAAc,CAAEoB,IAAI,CAAE,CAAR,CAAW3B,SAAS,CAAE,CAAtB,CAAd,CAAyC,CAE7DkB,KAAK,CAACX,IAAD,CAAL,CAAYoB,IAAZ,EAAoBA,IAApB,CACAT,KAAK,CAACX,IAAD,CAAL,CAAYP,SAAZ,EAAyBA,SAAzB,CACD,CATD,EAUD,CAfD,EAiBA,KAAM4B,CAAAA,WAAW,CAAGT,MAAM,CAACC,IAAP,CAAYF,KAAZ,EAAmBW,IAAnB,GAA0BC,GAA1B,CAA8BvB,IAAI,EAAI,CACxDwB,QAAQ,CAACxB,IAAD,CAAO,EAAP,CADgD,CAExDW,KAAK,CAACX,IAAD,CAAL,CAAYoB,IAF4C,CAGxDT,KAAK,CAACX,IAAD,CAAL,CAAYP,SAH4C,CAAtC,CAApB,CAMA,MAAO4B,CAAAA,WAAP,CACD,CAED,QAASJ,CAAAA,oBAAT,CAA+BD,WAA/B,CAA4CE,SAA5C,CAAuD,CACrD,KAAMO,CAAAA,UAAU,CAAG,GAAIxB,CAAAA,IAAJ,CAASiB,SAAT,CAAnB,CAEA,GAAIF,WAAW,EAAI,CAACU,KAAK,CAACC,OAAN,CAAcX,WAAW,CAAC,CAAD,CAAzB,CAApB,CAAmD,CAAEA,WAAW,CAAG,CAACA,WAAD,CAAd,CAA6B,CAElF,MAAOA,CAAAA,WAAW,CAACO,GAAZ,CAAiBd,KAAD,EAAW,CAChC,KAAMT,CAAAA,IAAI,CAAGyB,UAAU,CAACG,OAAX,CAAmBH,UAAU,CAACI,OAAX,EAAnB,CAAb,CACA,KAAMC,CAAAA,IAAI,CAAG,CAAC9B,IAAD,CAAO,GAAGS,KAAV,CAAb,CACAgB,UAAU,CAACG,OAAX,CAAmBH,UAAU,CAACI,OAAX,GAAuB,CAA1C,EACA,MAAOC,CAAAA,IAAP,CACD,CALM,CAAP,CAMD,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport _ from 'lodash'\n\nimport { apiGatewayClientWithCredentials } from './api'\nimport { store } from './state'\nimport { isAdmin } from './self'\n\n/* Catalog and API Utils */\n\n/**\n *\n * Does all operations to get user data at once.\n *\n * @param {Boolean} bustCache=true   Ignore the cache and re-make the calls? Defaults to true.\n */\nexport function updateAllUserData (bustCache = true) {\n  const promises = [\n    updateUsagePlansAndApisList(bustCache),\n    updateSubscriptions(bustCache),\n    updateApiKey(bustCache)\n  ]\n\n  if (isAdmin()) { promises.push(updateVisibility(bustCache)) }\n\n  return Promise.all(promises)\n}\n\n/**\n *\n * Update the catalog for the current user. Both request and response are cached, so unless the cache is busted, this should only ever make one network call.\n *\n * @param {Boolean} [bustCache=false]   Ignore the cache and re-make the network call. Defaults to false.\n *\n */\nexport function updateUsagePlansAndApisList (bustCache = false) {\n  // if we've already tried, just return that promise\n  if (!bustCache && catalogPromiseCache) return catalogPromiseCache\n\n  store.apiList.loaded = false\n\n  // eslint-disable-next-line no-return-assign\n  return catalogPromiseCache = apiGatewayClientWithCredentials()\n    .then(apiGatewayClient => apiGatewayClient.get('/catalog', {}, {}, {}))\n    .then(({ data = { apiGateway: [], generic: [] } }) => {\n      store.usagePlans = data.apiGateway\n      store.apiList = {\n        loaded: true,\n        apiGateway: getApiGatewayApisFromUsagePlans(store.usagePlans), // MUST create\n        generic: data.generic\n      }\n    })\n    .catch(() => {\n      store.usagePlans = []\n      store.apiList = {\n        loaded: true,\n        apiGateway: [],\n        generic: []\n      }\n    })\n}\nlet catalogPromiseCache // WARNING: Don't touch this. Should only be used by updateCatalogAndApisList.\n\n/**\n * A function that takes an input usage plans and creates an list of apis out of it.\n *\n * - Makes sure each api has a non-recursive 'usagePlan' object\n *\n * returns an array of apis\n */\nfunction getApiGatewayApisFromUsagePlans (usagePlans) {\n  return usagePlans.reduce((acc, usagePlan) => {\n    usagePlan.apis.forEach(api => {\n      api.usagePlan = _.cloneDeep(usagePlan)\n      // remove the apis from the cloned usagePlan so we don't go circular\n      delete api.usagePlan.apis\n    })\n\n    return acc.concat(usagePlan.apis)\n  }, [])\n}\n\n/**\n * Return the API with the provided apiId. Can also provide the special strings \"FIRST\" or \"ANY\" to get the first API returned. Can select the api returned as a side-effect.\n *\n * @param {String} apiId   An apiId or the special strings 'FIRST' or 'ANY'. 'FIRST' and 'ANY' both return the first api encountered.\n * @param {Boolean} [selectIt=false]   If true, sets the found API as the current 'selected' API.\n */\nexport function getApi (apiId, selectIt = false, stage, cacheBust = false) {\n  return updateUsagePlansAndApisList(cacheBust)\n    .then(() => {\n      let thisApi\n\n      const allApis = [].concat(store.apiList.apiGateway, store.apiList.generic)\n\n      if (allApis.length) {\n        if (apiId === 'ANY' || apiId === 'FIRST') {\n          thisApi = allApis[0]\n        } else {\n          thisApi = allApis.find(api => (api.apiId === apiId && api.apiStage === stage))\n\n          if (!thisApi) {\n            thisApi = allApis.find(api => (api.id.toString() === apiId))\n          }\n        }\n      }\n\n      if (selectIt) store.api = thisApi\n\n      return thisApi\n    })\n}\n\nexport function updateVisibility (cacheBust = false) {\n  return apiGatewayClientWithCredentials()\n    .then(app => app.get('/admin/catalog/visibility', {}, {}, {}))\n    .then(({ data }) => (store.visibility = data))\n}\n\n/* Subscription Utils */\n\n/**\n * Fetch and update subscriptions store. Uses caching to determine if it should actually fetch or return the stored result.\n *\n * @param {Boolean} [bustCache=false]   Ignore the cache and re-make the network call. Defaults to false.\n */\nexport function updateSubscriptions (bustCache = false) {\n  const subscriptionsOrPromise = store.subscriptions.length ? store.subscriptions : subscriptionsPromiseCache\n  if (!bustCache && subscriptionsOrPromise) return Promise.resolve(subscriptionsOrPromise)\n\n  // eslint-disable-next-line no-return-assign\n  return subscriptionsPromiseCache = apiGatewayClientWithCredentials()\n    .then(apiGatewayClient => apiGatewayClient.get('/subscriptions', {}, {}, {}))\n    .then(({ data }) => (store.subscriptions = data))\n}\nlet subscriptionsPromiseCache // WARNING: Don't touch this. Should only be used by updateCatalogAndApisList.\n\nexport function getSubscribedUsagePlan (usagePlanId) {\n  return store.subscriptions.find(sub => sub.id === usagePlanId)\n}\n\nexport function subscribe (usagePlanId) {\n  return apiGatewayClientWithCredentials()\n    .then(apiGatewayClient => apiGatewayClient.put('/subscriptions/' + usagePlanId, {}, {}))\n    .then(() => updateSubscriptions(true))\n}\n\nexport function unsubscribe (usagePlanId) {\n  return apiGatewayClientWithCredentials()\n    .then(apiGatewayClient => apiGatewayClient.delete(`/subscriptions/${usagePlanId}`, {}, {}))\n    .then(() => updateSubscriptions(true))\n}\n\n/**\n *\n * Fetches and updates the apiKey in the store. Both request and response are cached, so unless the cache is busted, this should only ever make one network call.\n *\n */\nexport function updateApiKey (bustCache) {\n  const apiKeyOrPromise = store.apiKey ? store.apiKey : apiKeyPromiseCache\n  if (!bustCache && apiKeyOrPromise) return Promise.resolve(apiKeyOrPromise)\n  store.apiKeyFetchFailed = false\n\n  const MAX_RETRIES = 5\n  let remaining = MAX_RETRIES\n\n  const timeouts = [\n    250,\n    500,\n    1000,\n    2000\n  ]\n\n  function loop () {\n    remaining--\n    const promise = apiGatewayClientWithCredentials()\n      .then(apiGatewayClient => apiGatewayClient.get('/apikey', {}, {}, {}))\n      .then(({ data }) => (store.apiKey = data.value))\n\n    return remaining\n      ? promise.catch(() =>\n        new Promise(resolve => setTimeout(resolve, timeouts[remaining])).then(loop)\n      )\n      : promise\n  }\n\n  return (apiKeyPromiseCache = loop()).catch(() => {\n    store.apiKeyFetchFailed = true\n  })\n}\nlet apiKeyPromiseCache\n\nexport function fetchUsage (usagePlanId) {\n  const date = new Date()\n  const start = new Date(date.getFullYear(), date.getMonth(), 1).toJSON().split('T')[0]\n  const end = date.toJSON().split('T')[0]\n  return apiGatewayClientWithCredentials()\n    .then(apiGatewayClient => apiGatewayClient.get('/subscriptions/' + usagePlanId + '/usage', { start, end }, {}))\n}\n\nexport function mapUsageByDate (usage, usedOrRemaining) {\n  const dates = {}\n  Object.keys(usage.items).forEach(apiKeyId => {\n    const apiKeyUsage = mapApiKeyUsageByDate(usage.items[apiKeyId], usage.startDate, usedOrRemaining)\n\n    // handles the bizarre case that the user has more than one api key\n    // currently not possible (and my never be), so we probably don't need it\n    apiKeyUsage.forEach(dailyUsage => {\n      const date = dailyUsage[0]\n      const used = dailyUsage[1]\n      const remaining = dailyUsage[2]\n\n      if (!dates[date]) { dates[date] = { used: 0, remaining: 0 } }\n\n      dates[date].used += used\n      dates[date].remaining += remaining\n    })\n  })\n\n  const usageByDate = Object.keys(dates).sort().map(date => [\n    parseInt(date, 10),\n    dates[date].used,\n    dates[date].remaining\n  ])\n\n  return usageByDate\n}\n\nfunction mapApiKeyUsageByDate (apiKeyUsage, startDate) {\n  const apiKeyDate = new Date(startDate)\n\n  if (apiKeyUsage && !Array.isArray(apiKeyUsage[0])) { apiKeyUsage = [apiKeyUsage] }\n\n  return apiKeyUsage.map((usage) => {\n    const date = apiKeyDate.setDate(apiKeyDate.getDate())\n    const item = [date, ...usage]\n    apiKeyDate.setDate(apiKeyDate.getDate() + 1)\n    return item\n  })\n}\n\n// Marketplace support is currently broken\n// /* Marketplace integration */\n//\n// export function confirmMarketplaceSubscription (usagePlanId, token) {\n//   if (!usagePlanId) {\n//     return\n//   }\n//\n//   return apiGatewayClientWithCredentials()\n//     .then(apiGatewayClient => apiGatewayClient.put('/marketplace-subscriptions/' + usagePlanId, {}, { token: token }))\n// }\n"]},"metadata":{},"sourceType":"module"}