{"ast":null,"code":"import _objectSpread from \"@babel/runtime-corejs3/helpers/objectSpread2\";\nimport _asyncToGenerator from \"@babel/runtime-corejs3/helpers/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs3/regenerator\"; // The subtree resolver is a higher-level interface that allows you to\n// get the same result that you would from `Swagger.resolve`, but focuses on\n// a subtree of your object.\n//\n// It makes several assumptions that allow you to think less about what resolve,\n// specmap, and normalizeSwagger are doing: if this is not suitable for you,\n// you can emulate `resolveSubtree`'s behavior by talking to the traditional\n// resolver directly.\n//\n// By providing a top-level `obj` and a `path` to resolve within, the subtree\n// at `path` will be resolved and normalized in the context of your top-level\n// `obj`. You'll get the resolved subtree you're interest in as a return value\n// (or, you can use `returnEntireTree` to get everything back).\n//\n// This is useful for cases where resolving your entire object is unnecessary\n// and/or non-performant; we use this interface for lazily resolving operations\n// and models in Swagger-UI, which allows us to handle larger definitions.\n//\n// It's likely that Swagger-Client will rely entirely on lazy resolving in\n// future versions.\n//\n// TODO: move the remarks above into project documentation\n\nimport get from 'lodash/get';\nimport resolve from '../resolver';\nimport { normalizeSwagger } from '../helpers';\nexport default function resolveSubtree(_x, _x2) {\n  return _resolveSubtree.apply(this, arguments);\n}\n\nfunction _resolveSubtree() {\n  _resolveSubtree = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(obj, path) {\n    var opts,\n        returnEntireTree,\n        baseDoc,\n        requestInterceptor,\n        responseInterceptor,\n        parameterMacro,\n        modelPropertyMacro,\n        useCircularStructures,\n        resolveOptions,\n        _normalizeSwagger,\n        normalized,\n        result,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n            returnEntireTree = opts.returnEntireTree, baseDoc = opts.baseDoc, requestInterceptor = opts.requestInterceptor, responseInterceptor = opts.responseInterceptor, parameterMacro = opts.parameterMacro, modelPropertyMacro = opts.modelPropertyMacro, useCircularStructures = opts.useCircularStructures;\n            resolveOptions = {\n              pathDiscriminator: path,\n              baseDoc: baseDoc,\n              requestInterceptor: requestInterceptor,\n              responseInterceptor: responseInterceptor,\n              parameterMacro: parameterMacro,\n              modelPropertyMacro: modelPropertyMacro,\n              useCircularStructures: useCircularStructures\n            };\n            _normalizeSwagger = normalizeSwagger({\n              spec: obj\n            }), normalized = _normalizeSwagger.spec;\n            _context.next = 6;\n            return resolve(_objectSpread(_objectSpread({}, resolveOptions), {}, {\n              spec: normalized,\n              allowMetaPatches: true,\n              skipNormalization: true\n            }));\n\n          case 6:\n            result = _context.sent;\n\n            if (!returnEntireTree && Array.isArray(path) && path.length) {\n              result.spec = get(result.spec, path) || null;\n            }\n\n            return _context.abrupt(\"return\", result);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _resolveSubtree.apply(this, arguments);\n}","map":{"version":3,"sources":["/home/daniyal/Downloads/vap-webapp (1)/vap-webapp/web-content/static-asset-uploader/node_modules/swagger-client/es/subtree-resolver/index.js"],"names":["_objectSpread","_asyncToGenerator","_regeneratorRuntime","get","resolve","normalizeSwagger","resolveSubtree","_x","_x2","_resolveSubtree","apply","arguments","mark","_callee","obj","path","opts","returnEntireTree","baseDoc","requestInterceptor","responseInterceptor","parameterMacro","modelPropertyMacro","useCircularStructures","resolveOptions","_normalizeSwagger","normalized","result","_args","wrap","_callee$","_context","prev","next","length","undefined","pathDiscriminator","spec","allowMetaPatches","skipNormalization","sent","Array","isArray","abrupt","stop"],"mappings":"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","sourcesContent":["import _objectSpread from \"@babel/runtime-corejs3/helpers/objectSpread2\";\nimport _asyncToGenerator from \"@babel/runtime-corejs3/helpers/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs3/regenerator\";\n// The subtree resolver is a higher-level interface that allows you to\n// get the same result that you would from `Swagger.resolve`, but focuses on\n// a subtree of your object.\n//\n// It makes several assumptions that allow you to think less about what resolve,\n// specmap, and normalizeSwagger are doing: if this is not suitable for you,\n// you can emulate `resolveSubtree`'s behavior by talking to the traditional\n// resolver directly.\n//\n// By providing a top-level `obj` and a `path` to resolve within, the subtree\n// at `path` will be resolved and normalized in the context of your top-level\n// `obj`. You'll get the resolved subtree you're interest in as a return value\n// (or, you can use `returnEntireTree` to get everything back).\n//\n// This is useful for cases where resolving your entire object is unnecessary\n// and/or non-performant; we use this interface for lazily resolving operations\n// and models in Swagger-UI, which allows us to handle larger definitions.\n//\n// It's likely that Swagger-Client will rely entirely on lazy resolving in\n// future versions.\n//\n// TODO: move the remarks above into project documentation\nimport get from 'lodash/get';\nimport resolve from '../resolver';\nimport { normalizeSwagger } from '../helpers';\nexport default function resolveSubtree(_x, _x2) {\n  return _resolveSubtree.apply(this, arguments);\n}\n\nfunction _resolveSubtree() {\n  _resolveSubtree = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(obj, path) {\n    var opts,\n        returnEntireTree,\n        baseDoc,\n        requestInterceptor,\n        responseInterceptor,\n        parameterMacro,\n        modelPropertyMacro,\n        useCircularStructures,\n        resolveOptions,\n        _normalizeSwagger,\n        normalized,\n        result,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n            returnEntireTree = opts.returnEntireTree, baseDoc = opts.baseDoc, requestInterceptor = opts.requestInterceptor, responseInterceptor = opts.responseInterceptor, parameterMacro = opts.parameterMacro, modelPropertyMacro = opts.modelPropertyMacro, useCircularStructures = opts.useCircularStructures;\n            resolveOptions = {\n              pathDiscriminator: path,\n              baseDoc: baseDoc,\n              requestInterceptor: requestInterceptor,\n              responseInterceptor: responseInterceptor,\n              parameterMacro: parameterMacro,\n              modelPropertyMacro: modelPropertyMacro,\n              useCircularStructures: useCircularStructures\n            };\n            _normalizeSwagger = normalizeSwagger({\n              spec: obj\n            }), normalized = _normalizeSwagger.spec;\n            _context.next = 6;\n            return resolve(_objectSpread(_objectSpread({}, resolveOptions), {}, {\n              spec: normalized,\n              allowMetaPatches: true,\n              skipNormalization: true\n            }));\n\n          case 6:\n            result = _context.sent;\n\n            if (!returnEntireTree && Array.isArray(path) && path.length) {\n              result.spec = get(result.spec, path) || null;\n            }\n\n            return _context.abrupt(\"return\", result);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _resolveSubtree.apply(this, arguments);\n}"]},"metadata":{},"sourceType":"module"}