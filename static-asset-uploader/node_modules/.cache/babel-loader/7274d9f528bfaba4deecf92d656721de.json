{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime-corejs3/helpers/toConsumableArray\";\nimport _objectSpread from \"@babel/runtime-corejs3/helpers/objectSpread2\";\nimport _sliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/slice\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport isEmpty from 'lodash/isEmpty';\nimport { isFreelyNamed, generateAbsoluteRefPatches } from '../helpers';\nexport default {\n  key: 'allOf',\n  plugin: function plugin(val, key, fullPath, specmap, patch) {\n    // Ignore replace patches created by $ref because the changes will\n    // occur in the original \"add\" patch and we don't want this plugin\n    // to redundantly processes those \"relace\" patches.\n    if (patch.meta && patch.meta.$$ref) {\n      return undefined;\n    }\n\n    var parent = _sliceInstanceProperty(fullPath).call(fullPath, 0, -1);\n\n    if (isFreelyNamed(parent)) {\n      return undefined;\n    }\n\n    if (!Array.isArray(val)) {\n      var err = new TypeError('allOf must be an array');\n      err.fullPath = fullPath; // This is an array\n\n      return err;\n    }\n\n    var alreadyAddError = false; // Find the original definition from the `patch.value` object\n    // Remove the `allOf` property so it doesn't get added to the result of the `allOf` plugin\n\n    var originalDefinitionObj = patch.value;\n    parent.forEach(function (part) {\n      if (!originalDefinitionObj) return; // bail out if we've lost sight of our target\n\n      originalDefinitionObj = originalDefinitionObj[part];\n    });\n    originalDefinitionObj = _objectSpread({}, originalDefinitionObj); // when we've lost sight, interrupt prematurely\n\n    if (isEmpty(originalDefinitionObj)) {\n      return undefined;\n    }\n\n    delete originalDefinitionObj.allOf;\n    var patches = []; // remove existing content\n\n    patches.push(specmap.replace(parent, {}));\n    val.forEach(function (toMerge, i) {\n      if (!specmap.isObject(toMerge)) {\n        if (alreadyAddError) {\n          return null;\n        }\n\n        alreadyAddError = true;\n\n        var _err = new TypeError('Elements in allOf must be objects');\n\n        _err.fullPath = fullPath; // This is an array\n\n        return patches.push(_err);\n      } // Deeply merge the member's contents onto the parent location\n\n\n      patches.push(specmap.mergeDeep(parent, toMerge)); // Generate patches that migrate $ref values based on ContextTree information\n      // remove [\"allOf\"], which will not be present when these patches are applied\n\n      var collapsedFullPath = _sliceInstanceProperty(fullPath).call(fullPath, 0, -1);\n\n      var absoluteRefPatches = generateAbsoluteRefPatches(toMerge, collapsedFullPath, {\n        getBaseUrlForNodePath: function getBaseUrlForNodePath(nodePath) {\n          var _context;\n\n          return specmap.getContext(_concatInstanceProperty(_context = []).call(_context, _toConsumableArray(fullPath), [i], _toConsumableArray(nodePath))).baseDoc;\n        },\n        specmap: specmap\n      });\n      patches.push.apply(patches, _toConsumableArray(absoluteRefPatches));\n      return undefined;\n    }); // Merge back the values from the original definition\n\n    patches.push(specmap.mergeDeep(parent, originalDefinitionObj)); // If there was not an original $$ref value, make sure to remove\n    // any $$ref value that may exist from the result of `allOf` merges\n\n    if (!originalDefinitionObj.$$ref) {\n      var _context2;\n\n      patches.push(specmap.remove(_concatInstanceProperty(_context2 = []).call(_context2, parent, '$$ref')));\n    }\n\n    return patches;\n  }\n};","map":{"version":3,"sources":["/home/daniyal/Downloads/vap-webapp (1)/vap-webapp/web-content/static-asset-uploader/node_modules/swagger-client/es/specmap/lib/all-of.js"],"names":["_toConsumableArray","_objectSpread","_sliceInstanceProperty","_concatInstanceProperty","isEmpty","isFreelyNamed","generateAbsoluteRefPatches","key","plugin","val","fullPath","specmap","patch","meta","$$ref","undefined","parent","call","Array","isArray","err","TypeError","alreadyAddError","originalDefinitionObj","value","forEach","part","allOf","patches","push","replace","toMerge","i","isObject","_err","mergeDeep","collapsedFullPath","absoluteRefPatches","getBaseUrlForNodePath","nodePath","_context","getContext","baseDoc","apply","_context2","remove"],"mappings":"AAAA,OAAOA,kBAAP,MAA+B,kDAA/B;AACA,OAAOC,aAAP,MAA0B,8CAA1B;AACA,OAAOC,sBAAP,MAAmC,sDAAnC;AACA,OAAOC,uBAAP,MAAoC,uDAApC;AACA,OAAOC,OAAP,MAAoB,gBAApB;AACA,SAASC,aAAT,EAAwBC,0BAAxB,QAA0D,YAA1D;AACA,eAAe;AACbC,EAAAA,GAAG,EAAE,OADQ;AAEbC,EAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBC,GAAhB,EAAqBF,GAArB,EAA0BG,QAA1B,EAAoCC,OAApC,EAA6CC,KAA7C,EAAoD;AAC1D;AACA;AACA;AACA,QAAIA,KAAK,CAACC,IAAN,IAAcD,KAAK,CAACC,IAAN,CAAWC,KAA7B,EAAoC;AAClC,aAAOC,SAAP;AACD;;AAED,QAAIC,MAAM,GAAGd,sBAAsB,CAACQ,QAAD,CAAtB,CAAiCO,IAAjC,CAAsCP,QAAtC,EAAgD,CAAhD,EAAmD,CAAC,CAApD,CAAb;;AAEA,QAAIL,aAAa,CAACW,MAAD,CAAjB,EAA2B;AACzB,aAAOD,SAAP;AACD;;AAED,QAAI,CAACG,KAAK,CAACC,OAAN,CAAcV,GAAd,CAAL,EAAyB;AACvB,UAAIW,GAAG,GAAG,IAAIC,SAAJ,CAAc,wBAAd,CAAV;AACAD,MAAAA,GAAG,CAACV,QAAJ,GAAeA,QAAf,CAFuB,CAEE;;AAEzB,aAAOU,GAAP;AACD;;AAED,QAAIE,eAAe,GAAG,KAAtB,CArB0D,CAqB7B;AAC7B;;AAEA,QAAIC,qBAAqB,GAAGX,KAAK,CAACY,KAAlC;AACAR,IAAAA,MAAM,CAACS,OAAP,CAAe,UAAUC,IAAV,EAAgB;AAC7B,UAAI,CAACH,qBAAL,EAA4B,OADC,CACO;;AAEpCA,MAAAA,qBAAqB,GAAGA,qBAAqB,CAACG,IAAD,CAA7C;AACD,KAJD;AAKAH,IAAAA,qBAAqB,GAAGtB,aAAa,CAAC,EAAD,EAAKsB,qBAAL,CAArC,CA9B0D,CA8BQ;;AAElE,QAAInB,OAAO,CAACmB,qBAAD,CAAX,EAAoC;AAClC,aAAOR,SAAP;AACD;;AAED,WAAOQ,qBAAqB,CAACI,KAA7B;AACA,QAAIC,OAAO,GAAG,EAAd,CArC0D,CAqCxC;;AAElBA,IAAAA,OAAO,CAACC,IAAR,CAAalB,OAAO,CAACmB,OAAR,CAAgBd,MAAhB,EAAwB,EAAxB,CAAb;AACAP,IAAAA,GAAG,CAACgB,OAAJ,CAAY,UAAUM,OAAV,EAAmBC,CAAnB,EAAsB;AAChC,UAAI,CAACrB,OAAO,CAACsB,QAAR,CAAiBF,OAAjB,CAAL,EAAgC;AAC9B,YAAIT,eAAJ,EAAqB;AACnB,iBAAO,IAAP;AACD;;AAEDA,QAAAA,eAAe,GAAG,IAAlB;;AAEA,YAAIY,IAAI,GAAG,IAAIb,SAAJ,CAAc,mCAAd,CAAX;;AAEAa,QAAAA,IAAI,CAACxB,QAAL,GAAgBA,QAAhB,CAT8B,CASJ;;AAE1B,eAAOkB,OAAO,CAACC,IAAR,CAAaK,IAAb,CAAP;AACD,OAb+B,CAa9B;;;AAGFN,MAAAA,OAAO,CAACC,IAAR,CAAalB,OAAO,CAACwB,SAAR,CAAkBnB,MAAlB,EAA0Be,OAA1B,CAAb,EAhBgC,CAgBkB;AAClD;;AAEA,UAAIK,iBAAiB,GAAGlC,sBAAsB,CAACQ,QAAD,CAAtB,CAAiCO,IAAjC,CAAsCP,QAAtC,EAAgD,CAAhD,EAAmD,CAAC,CAApD,CAAxB;;AAEA,UAAI2B,kBAAkB,GAAG/B,0BAA0B,CAACyB,OAAD,EAAUK,iBAAV,EAA6B;AAC9EE,QAAAA,qBAAqB,EAAE,SAASA,qBAAT,CAA+BC,QAA/B,EAAyC;AAC9D,cAAIC,QAAJ;;AAEA,iBAAO7B,OAAO,CAAC8B,UAAR,CAAmBtC,uBAAuB,CAACqC,QAAQ,GAAG,EAAZ,CAAvB,CAAuCvB,IAAvC,CAA4CuB,QAA5C,EAAsDxC,kBAAkB,CAACU,QAAD,CAAxE,EAAoF,CAACsB,CAAD,CAApF,EAAyFhC,kBAAkB,CAACuC,QAAD,CAA3G,CAAnB,EAA2IG,OAAlJ;AACD,SAL6E;AAM9E/B,QAAAA,OAAO,EAAEA;AANqE,OAA7B,CAAnD;AAQAiB,MAAAA,OAAO,CAACC,IAAR,CAAac,KAAb,CAAmBf,OAAnB,EAA4B5B,kBAAkB,CAACqC,kBAAD,CAA9C;AACA,aAAOtB,SAAP;AACD,KA/BD,EAxC0D,CAuEtD;;AAEJa,IAAAA,OAAO,CAACC,IAAR,CAAalB,OAAO,CAACwB,SAAR,CAAkBnB,MAAlB,EAA0BO,qBAA1B,CAAb,EAzE0D,CAyEM;AAChE;;AAEA,QAAI,CAACA,qBAAqB,CAACT,KAA3B,EAAkC;AAChC,UAAI8B,SAAJ;;AAEAhB,MAAAA,OAAO,CAACC,IAAR,CAAalB,OAAO,CAACkC,MAAR,CAAe1C,uBAAuB,CAACyC,SAAS,GAAG,EAAb,CAAvB,CAAwC3B,IAAxC,CAA6C2B,SAA7C,EAAwD5B,MAAxD,EAAgE,OAAhE,CAAf,CAAb;AACD;;AAED,WAAOY,OAAP;AACD;AArFY,CAAf","sourcesContent":["import _toConsumableArray from \"@babel/runtime-corejs3/helpers/toConsumableArray\";\nimport _objectSpread from \"@babel/runtime-corejs3/helpers/objectSpread2\";\nimport _sliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/slice\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport isEmpty from 'lodash/isEmpty';\nimport { isFreelyNamed, generateAbsoluteRefPatches } from '../helpers';\nexport default {\n  key: 'allOf',\n  plugin: function plugin(val, key, fullPath, specmap, patch) {\n    // Ignore replace patches created by $ref because the changes will\n    // occur in the original \"add\" patch and we don't want this plugin\n    // to redundantly processes those \"relace\" patches.\n    if (patch.meta && patch.meta.$$ref) {\n      return undefined;\n    }\n\n    var parent = _sliceInstanceProperty(fullPath).call(fullPath, 0, -1);\n\n    if (isFreelyNamed(parent)) {\n      return undefined;\n    }\n\n    if (!Array.isArray(val)) {\n      var err = new TypeError('allOf must be an array');\n      err.fullPath = fullPath; // This is an array\n\n      return err;\n    }\n\n    var alreadyAddError = false; // Find the original definition from the `patch.value` object\n    // Remove the `allOf` property so it doesn't get added to the result of the `allOf` plugin\n\n    var originalDefinitionObj = patch.value;\n    parent.forEach(function (part) {\n      if (!originalDefinitionObj) return; // bail out if we've lost sight of our target\n\n      originalDefinitionObj = originalDefinitionObj[part];\n    });\n    originalDefinitionObj = _objectSpread({}, originalDefinitionObj); // when we've lost sight, interrupt prematurely\n\n    if (isEmpty(originalDefinitionObj)) {\n      return undefined;\n    }\n\n    delete originalDefinitionObj.allOf;\n    var patches = []; // remove existing content\n\n    patches.push(specmap.replace(parent, {}));\n    val.forEach(function (toMerge, i) {\n      if (!specmap.isObject(toMerge)) {\n        if (alreadyAddError) {\n          return null;\n        }\n\n        alreadyAddError = true;\n\n        var _err = new TypeError('Elements in allOf must be objects');\n\n        _err.fullPath = fullPath; // This is an array\n\n        return patches.push(_err);\n      } // Deeply merge the member's contents onto the parent location\n\n\n      patches.push(specmap.mergeDeep(parent, toMerge)); // Generate patches that migrate $ref values based on ContextTree information\n      // remove [\"allOf\"], which will not be present when these patches are applied\n\n      var collapsedFullPath = _sliceInstanceProperty(fullPath).call(fullPath, 0, -1);\n\n      var absoluteRefPatches = generateAbsoluteRefPatches(toMerge, collapsedFullPath, {\n        getBaseUrlForNodePath: function getBaseUrlForNodePath(nodePath) {\n          var _context;\n\n          return specmap.getContext(_concatInstanceProperty(_context = []).call(_context, _toConsumableArray(fullPath), [i], _toConsumableArray(nodePath))).baseDoc;\n        },\n        specmap: specmap\n      });\n      patches.push.apply(patches, _toConsumableArray(absoluteRefPatches));\n      return undefined;\n    }); // Merge back the values from the original definition\n\n    patches.push(specmap.mergeDeep(parent, originalDefinitionObj)); // If there was not an original $$ref value, make sure to remove\n    // any $$ref value that may exist from the result of `allOf` merges\n\n    if (!originalDefinitionObj.$$ref) {\n      var _context2;\n\n      patches.push(specmap.remove(_concatInstanceProperty(_context2 = []).call(_context2, parent, '$$ref')));\n    }\n\n    return patches;\n  }\n};"]},"metadata":{},"sourceType":"module"}