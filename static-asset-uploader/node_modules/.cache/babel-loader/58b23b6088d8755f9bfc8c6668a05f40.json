{"ast":null,"code":"import _createForOfIteratorHelper from \"@babel/runtime-corejs3/helpers/createForOfIteratorHelper\";\nimport _typeof from \"@babel/runtime-corejs3/helpers/typeof\";\nimport _startsWithInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/starts-with\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport isObject from 'lodash/isObject';\n\nvar toLower = function toLower(str) {\n  return String.prototype.toLowerCase.call(str);\n};\n\nvar escapeString = function escapeString(str) {\n  return str.replace(/[^\\w]/gi, '_');\n}; // Spec version detection\n\n\nexport function isOAS3(spec) {\n  var oasVersion = spec.openapi;\n\n  if (!oasVersion) {\n    return false;\n  }\n\n  return _startsWithInstanceProperty(oasVersion).call(oasVersion, '3');\n}\nexport function isSwagger2(spec) {\n  var swaggerVersion = spec.swagger;\n\n  if (!swaggerVersion) {\n    return false;\n  }\n\n  return _startsWithInstanceProperty(swaggerVersion).call(swaggerVersion, '2');\n} // Strategy for determining operationId\n\nexport function opId(operation, pathName) {\n  var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      v2OperationIdCompatibilityMode = _ref.v2OperationIdCompatibilityMode;\n\n  if (!operation || _typeof(operation) !== 'object') {\n    return null;\n  }\n\n  var idWithoutWhitespace = (operation.operationId || '').replace(/\\s/g, '');\n\n  if (idWithoutWhitespace.length) {\n    return escapeString(operation.operationId);\n  }\n\n  return idFromPathMethod(pathName, method, {\n    v2OperationIdCompatibilityMode: v2OperationIdCompatibilityMode\n  });\n} // Create a generated operationId from pathName + method\n\nexport function idFromPathMethod(pathName, method) {\n  var _context3;\n\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      v2OperationIdCompatibilityMode = _ref2.v2OperationIdCompatibilityMode;\n\n  if (v2OperationIdCompatibilityMode) {\n    var _context, _context2;\n\n    var res = _concatInstanceProperty(_context = \"\".concat(method.toLowerCase(), \"_\")).call(_context, pathName).replace(/[\\s!@#$%^&*()_+=[{\\]};:<>|./?,\\\\'\"\"-]/g, '_');\n\n    res = res || _concatInstanceProperty(_context2 = \"\".concat(pathName.substring(1), \"_\")).call(_context2, method);\n    return res.replace(/((_){2,})/g, '_').replace(/^(_)*/g, '').replace(/([_])*$/g, '');\n  }\n\n  return _concatInstanceProperty(_context3 = \"\".concat(toLower(method))).call(_context3, escapeString(pathName));\n}\nexport function legacyIdFromPathMethod(pathName, method) {\n  var _context4;\n\n  return _concatInstanceProperty(_context4 = \"\".concat(toLower(method), \"-\")).call(_context4, pathName);\n} // Get the operation, based on operationId ( just return the object, no inheritence )\n\nexport function getOperationRaw(spec, id) {\n  if (!spec || !spec.paths) {\n    return null;\n  }\n\n  return findOperation(spec, function (_ref3) {\n    var pathName = _ref3.pathName,\n        method = _ref3.method,\n        operation = _ref3.operation;\n\n    if (!operation || _typeof(operation) !== 'object') {\n      return false;\n    }\n\n    var rawOperationId = operation.operationId; // straight from the source\n\n    var operationId = opId(operation, pathName, method);\n    var legacyOperationId = legacyIdFromPathMethod(pathName, method);\n    return [operationId, legacyOperationId, rawOperationId].some(function (val) {\n      return val && val === id;\n    });\n  });\n} // Will stop iterating over the operations and return the operationObj\n// as soon as predicate returns true\n\nexport function findOperation(spec, predicate) {\n  return eachOperation(spec, predicate, true) || null;\n} // iterate over each operation, and fire a callback with details\n// `find=true` will stop iterating, when the cb returns truthy\n\nexport function eachOperation(spec, cb, find) {\n  if (!spec || _typeof(spec) !== 'object' || !spec.paths || _typeof(spec.paths) !== 'object') {\n    return null;\n  }\n\n  var paths = spec.paths; // Iterate over the spec, collecting operations\n  // eslint-disable-next-line no-restricted-syntax, guard-for-in\n\n  for (var pathName in paths) {\n    // eslint-disable-next-line no-restricted-syntax, guard-for-in\n    for (var method in paths[pathName]) {\n      if (method.toUpperCase() === 'PARAMETERS') {\n        continue; // eslint-disable-line no-continue\n      }\n\n      var operation = paths[pathName][method];\n\n      if (!operation || _typeof(operation) !== 'object') {\n        continue; // eslint-disable-line no-continue\n      }\n\n      var operationObj = {\n        spec: spec,\n        pathName: pathName,\n        method: method.toUpperCase(),\n        operation: operation\n      };\n      var cbValue = cb(operationObj);\n\n      if (find && cbValue) {\n        return operationObj;\n      }\n    }\n  }\n\n  return undefined;\n} // REVIEW: OAS3: identify normalization steps that need changes\n// ...maybe create `normalizeOAS3`?\n\nexport function normalizeSwagger(parsedSpec) {\n  var spec = parsedSpec.spec;\n  var paths = spec.paths;\n  var map = {};\n\n  if (!paths || spec.$$normalized) {\n    return parsedSpec;\n  } // eslint-disable-next-line no-restricted-syntax, guard-for-in\n\n\n  for (var pathName in paths) {\n    var path = paths[pathName];\n\n    if (!isObject(path)) {\n      continue; // eslint-disable-line no-continue\n    }\n\n    var pathParameters = path.parameters; // eslint-disable-next-line no-restricted-syntax, guard-for-in\n\n    var _loop = function _loop(method) {\n      var operation = path[method];\n\n      if (!isObject(operation)) {\n        return \"continue\"; // eslint-disable-line no-continue\n      }\n\n      var oid = opId(operation, pathName, method);\n\n      if (oid) {\n        if (map[oid]) {\n          map[oid].push(operation);\n        } else {\n          map[oid] = [operation];\n        }\n\n        var opList = map[oid];\n\n        if (opList.length > 1) {\n          opList.forEach(function (o, i) {\n            var _context5; // eslint-disable-next-line no-underscore-dangle\n\n\n            o.__originalOperationId = o.__originalOperationId || o.operationId;\n            o.operationId = _concatInstanceProperty(_context5 = \"\".concat(oid)).call(_context5, i + 1);\n          });\n        } else if (typeof operation.operationId !== 'undefined') {\n          // Ensure we always add the normalized operation ID if one already exists\n          // ( potentially different, given that we normalize our IDs)\n          // ... _back_ to the spec. Otherwise, they might not line up\n          var obj = opList[0]; // eslint-disable-next-line no-underscore-dangle\n\n          obj.__originalOperationId = obj.__originalOperationId || operation.operationId;\n          obj.operationId = oid;\n        }\n      }\n\n      if (method !== 'parameters') {\n        // Add inherited consumes, produces, parameters, securities\n        var inheritsList = [];\n        var toBeInherit = {}; // Global-levels\n        // eslint-disable-next-line no-restricted-syntax\n\n        for (var key in spec) {\n          if (key === 'produces' || key === 'consumes' || key === 'security') {\n            toBeInherit[key] = spec[key];\n            inheritsList.push(toBeInherit);\n          }\n        } // Path-levels\n\n\n        if (pathParameters) {\n          toBeInherit.parameters = pathParameters;\n          inheritsList.push(toBeInherit);\n        }\n\n        if (inheritsList.length) {\n          // eslint-disable-next-line no-restricted-syntax\n          var _iterator = _createForOfIteratorHelper(inheritsList),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var inherits = _step.value; // eslint-disable-next-line no-restricted-syntax\n\n              for (var inheritName in inherits) {\n                if (!operation[inheritName]) {\n                  operation[inheritName] = inherits[inheritName];\n                } else if (inheritName === 'parameters') {\n                  // eslint-disable-next-line no-restricted-syntax\n                  var _iterator2 = _createForOfIteratorHelper(inherits[inheritName]),\n                      _step2;\n\n                  try {\n                    var _loop2 = function _loop2() {\n                      var param = _step2.value;\n                      var exists = operation[inheritName].some(function (opParam) {\n                        return opParam.name && opParam.name === param.name || opParam.$ref && opParam.$ref === param.$ref || opParam.$$ref && opParam.$$ref === param.$$ref || opParam === param;\n                      });\n\n                      if (!exists) {\n                        operation[inheritName].push(param);\n                      }\n                    };\n\n                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                      _loop2();\n                    }\n                  } catch (err) {\n                    _iterator2.e(err);\n                  } finally {\n                    _iterator2.f();\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n    };\n\n    for (var method in path) {\n      var _ret = _loop(method);\n\n      if (_ret === \"continue\") continue;\n    }\n  }\n\n  spec.$$normalized = true;\n  return parsedSpec;\n}","map":{"version":3,"sources":["/home/daniyal/Downloads/vap-webapp (1)/vap-webapp/web-content/static-asset-uploader/node_modules/swagger-client/es/helpers.js"],"names":["_createForOfIteratorHelper","_typeof","_startsWithInstanceProperty","_concatInstanceProperty","isObject","toLower","str","String","prototype","toLowerCase","call","escapeString","replace","isOAS3","spec","oasVersion","openapi","isSwagger2","swaggerVersion","swagger","opId","operation","pathName","method","arguments","length","undefined","_ref","v2OperationIdCompatibilityMode","idWithoutWhitespace","operationId","idFromPathMethod","_context3","_ref2","_context","_context2","res","concat","substring","legacyIdFromPathMethod","_context4","getOperationRaw","id","paths","findOperation","_ref3","rawOperationId","legacyOperationId","some","val","predicate","eachOperation","cb","find","toUpperCase","operationObj","cbValue","normalizeSwagger","parsedSpec","map","$$normalized","path","pathParameters","parameters","_loop","oid","push","opList","forEach","o","i","_context5","__originalOperationId","obj","inheritsList","toBeInherit","key","_iterator","_step","s","n","done","inherits","value","inheritName","_iterator2","_step2","_loop2","param","exists","opParam","name","$ref","$$ref","err","e","f","_ret"],"mappings":"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","sourcesContent":["import _createForOfIteratorHelper from \"@babel/runtime-corejs3/helpers/createForOfIteratorHelper\";\nimport _typeof from \"@babel/runtime-corejs3/helpers/typeof\";\nimport _startsWithInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/starts-with\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport isObject from 'lodash/isObject';\n\nvar toLower = function toLower(str) {\n  return String.prototype.toLowerCase.call(str);\n};\n\nvar escapeString = function escapeString(str) {\n  return str.replace(/[^\\w]/gi, '_');\n}; // Spec version detection\n\n\nexport function isOAS3(spec) {\n  var oasVersion = spec.openapi;\n\n  if (!oasVersion) {\n    return false;\n  }\n\n  return _startsWithInstanceProperty(oasVersion).call(oasVersion, '3');\n}\nexport function isSwagger2(spec) {\n  var swaggerVersion = spec.swagger;\n\n  if (!swaggerVersion) {\n    return false;\n  }\n\n  return _startsWithInstanceProperty(swaggerVersion).call(swaggerVersion, '2');\n} // Strategy for determining operationId\n\nexport function opId(operation, pathName) {\n  var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      v2OperationIdCompatibilityMode = _ref.v2OperationIdCompatibilityMode;\n\n  if (!operation || _typeof(operation) !== 'object') {\n    return null;\n  }\n\n  var idWithoutWhitespace = (operation.operationId || '').replace(/\\s/g, '');\n\n  if (idWithoutWhitespace.length) {\n    return escapeString(operation.operationId);\n  }\n\n  return idFromPathMethod(pathName, method, {\n    v2OperationIdCompatibilityMode: v2OperationIdCompatibilityMode\n  });\n} // Create a generated operationId from pathName + method\n\nexport function idFromPathMethod(pathName, method) {\n  var _context3;\n\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      v2OperationIdCompatibilityMode = _ref2.v2OperationIdCompatibilityMode;\n\n  if (v2OperationIdCompatibilityMode) {\n    var _context, _context2;\n\n    var res = _concatInstanceProperty(_context = \"\".concat(method.toLowerCase(), \"_\")).call(_context, pathName).replace(/[\\s!@#$%^&*()_+=[{\\]};:<>|./?,\\\\'\"\"-]/g, '_');\n\n    res = res || _concatInstanceProperty(_context2 = \"\".concat(pathName.substring(1), \"_\")).call(_context2, method);\n    return res.replace(/((_){2,})/g, '_').replace(/^(_)*/g, '').replace(/([_])*$/g, '');\n  }\n\n  return _concatInstanceProperty(_context3 = \"\".concat(toLower(method))).call(_context3, escapeString(pathName));\n}\nexport function legacyIdFromPathMethod(pathName, method) {\n  var _context4;\n\n  return _concatInstanceProperty(_context4 = \"\".concat(toLower(method), \"-\")).call(_context4, pathName);\n} // Get the operation, based on operationId ( just return the object, no inheritence )\n\nexport function getOperationRaw(spec, id) {\n  if (!spec || !spec.paths) {\n    return null;\n  }\n\n  return findOperation(spec, function (_ref3) {\n    var pathName = _ref3.pathName,\n        method = _ref3.method,\n        operation = _ref3.operation;\n\n    if (!operation || _typeof(operation) !== 'object') {\n      return false;\n    }\n\n    var rawOperationId = operation.operationId; // straight from the source\n\n    var operationId = opId(operation, pathName, method);\n    var legacyOperationId = legacyIdFromPathMethod(pathName, method);\n    return [operationId, legacyOperationId, rawOperationId].some(function (val) {\n      return val && val === id;\n    });\n  });\n} // Will stop iterating over the operations and return the operationObj\n// as soon as predicate returns true\n\nexport function findOperation(spec, predicate) {\n  return eachOperation(spec, predicate, true) || null;\n} // iterate over each operation, and fire a callback with details\n// `find=true` will stop iterating, when the cb returns truthy\n\nexport function eachOperation(spec, cb, find) {\n  if (!spec || _typeof(spec) !== 'object' || !spec.paths || _typeof(spec.paths) !== 'object') {\n    return null;\n  }\n\n  var paths = spec.paths; // Iterate over the spec, collecting operations\n  // eslint-disable-next-line no-restricted-syntax, guard-for-in\n\n  for (var pathName in paths) {\n    // eslint-disable-next-line no-restricted-syntax, guard-for-in\n    for (var method in paths[pathName]) {\n      if (method.toUpperCase() === 'PARAMETERS') {\n        continue; // eslint-disable-line no-continue\n      }\n\n      var operation = paths[pathName][method];\n\n      if (!operation || _typeof(operation) !== 'object') {\n        continue; // eslint-disable-line no-continue\n      }\n\n      var operationObj = {\n        spec: spec,\n        pathName: pathName,\n        method: method.toUpperCase(),\n        operation: operation\n      };\n      var cbValue = cb(operationObj);\n\n      if (find && cbValue) {\n        return operationObj;\n      }\n    }\n  }\n\n  return undefined;\n} // REVIEW: OAS3: identify normalization steps that need changes\n// ...maybe create `normalizeOAS3`?\n\nexport function normalizeSwagger(parsedSpec) {\n  var spec = parsedSpec.spec;\n  var paths = spec.paths;\n  var map = {};\n\n  if (!paths || spec.$$normalized) {\n    return parsedSpec;\n  } // eslint-disable-next-line no-restricted-syntax, guard-for-in\n\n\n  for (var pathName in paths) {\n    var path = paths[pathName];\n\n    if (!isObject(path)) {\n      continue; // eslint-disable-line no-continue\n    }\n\n    var pathParameters = path.parameters; // eslint-disable-next-line no-restricted-syntax, guard-for-in\n\n    var _loop = function _loop(method) {\n      var operation = path[method];\n\n      if (!isObject(operation)) {\n        return \"continue\"; // eslint-disable-line no-continue\n      }\n\n      var oid = opId(operation, pathName, method);\n\n      if (oid) {\n        if (map[oid]) {\n          map[oid].push(operation);\n        } else {\n          map[oid] = [operation];\n        }\n\n        var opList = map[oid];\n\n        if (opList.length > 1) {\n          opList.forEach(function (o, i) {\n            var _context5;\n\n            // eslint-disable-next-line no-underscore-dangle\n            o.__originalOperationId = o.__originalOperationId || o.operationId;\n            o.operationId = _concatInstanceProperty(_context5 = \"\".concat(oid)).call(_context5, i + 1);\n          });\n        } else if (typeof operation.operationId !== 'undefined') {\n          // Ensure we always add the normalized operation ID if one already exists\n          // ( potentially different, given that we normalize our IDs)\n          // ... _back_ to the spec. Otherwise, they might not line up\n          var obj = opList[0]; // eslint-disable-next-line no-underscore-dangle\n\n          obj.__originalOperationId = obj.__originalOperationId || operation.operationId;\n          obj.operationId = oid;\n        }\n      }\n\n      if (method !== 'parameters') {\n        // Add inherited consumes, produces, parameters, securities\n        var inheritsList = [];\n        var toBeInherit = {}; // Global-levels\n        // eslint-disable-next-line no-restricted-syntax\n\n        for (var key in spec) {\n          if (key === 'produces' || key === 'consumes' || key === 'security') {\n            toBeInherit[key] = spec[key];\n            inheritsList.push(toBeInherit);\n          }\n        } // Path-levels\n\n\n        if (pathParameters) {\n          toBeInherit.parameters = pathParameters;\n          inheritsList.push(toBeInherit);\n        }\n\n        if (inheritsList.length) {\n          // eslint-disable-next-line no-restricted-syntax\n          var _iterator = _createForOfIteratorHelper(inheritsList),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var inherits = _step.value;\n\n              // eslint-disable-next-line no-restricted-syntax\n              for (var inheritName in inherits) {\n                if (!operation[inheritName]) {\n                  operation[inheritName] = inherits[inheritName];\n                } else if (inheritName === 'parameters') {\n                  // eslint-disable-next-line no-restricted-syntax\n                  var _iterator2 = _createForOfIteratorHelper(inherits[inheritName]),\n                      _step2;\n\n                  try {\n                    var _loop2 = function _loop2() {\n                      var param = _step2.value;\n                      var exists = operation[inheritName].some(function (opParam) {\n                        return opParam.name && opParam.name === param.name || opParam.$ref && opParam.$ref === param.$ref || opParam.$$ref && opParam.$$ref === param.$$ref || opParam === param;\n                      });\n\n                      if (!exists) {\n                        operation[inheritName].push(param);\n                      }\n                    };\n\n                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                      _loop2();\n                    }\n                  } catch (err) {\n                    _iterator2.e(err);\n                  } finally {\n                    _iterator2.f();\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n    };\n\n    for (var method in path) {\n      var _ret = _loop(method);\n\n      if (_ret === \"continue\") continue;\n    }\n  }\n\n  spec.$$normalized = true;\n  return parsedSpec;\n}"]},"metadata":{},"sourceType":"module"}